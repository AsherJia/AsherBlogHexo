<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          We have a problem with promise - AsherJia的博客 | AsherJia&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://blog.asherjia.com/2016/07/04/we-have-a-problem-with-promise/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Asher&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/news/">News</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://blog.asherjia.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Promise" title="Promise">Promise</a>
                        
                    </div>
                    <h1>We have a problem with promise</h1>
                    <h2 class="subheading">Promise</h2>
                    <span class="meta">
                        Posted by Asher on
                        2016-07-04
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="下面四种Promise的区别"><a href="#下面四种Promise的区别" class="headerlink" title="下面四种Promise的区别"></a><em>下面四种Promise的区别</em></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">doSomething().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> doSomethingElse()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">doSomething().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    doSomethingElse()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">doSomething().then(doSomethingElse())</div><div class="line"></div><div class="line">doSomething().then(doSomethingElse)</div></pre></td></tr></table></figure>
<h2 id="Promise的起源"><a href="#Promise的起源" class="headerlink" title="Promise的起源"></a>Promise的起源</h2><p>如果你阅读了 promises 的一些相关文献，你会发现有一个词 <a href="https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf#.ca5u6o9fl" target="_blank" rel="external">金字塔问题</a> 经常出现。它描述的是大量的回调函数慢慢向右侧屏幕延伸的一种状态。</p>
<p>Promises 的确解决了这个问题，并且不仅仅是缩进问题。就像在 <a href="http://youtu.be/hf1T_AONQJU" target="_blank" rel="external">Callback Hell的救赎</a> 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。相反，我们的整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。</p>
<blockquote>
<p>原文关于副作用的描述并不能很直观的进行理解，建议参考 <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science" target="_blank" rel="external">WIKI</a>) 。简单来说就是一个函数除了会返回一个值之外，还会修改函数以外的状态如全局变量等等。实际上所有异步调用都可以视为带有副作用的行为。</p>
</blockquote>
<p>并且实际上，回调更加恼人的是，他会将我们通常在大部分编程语言中能获得的<em>堆栈</em>破坏。编写代码时如果无法获取堆栈就像开车时没有刹车一样: 不到用的时候，你不会知道它有多重要。</p>
<p>Promises 给予我们的就是在我们使用异步时丢失的最重要的语言基石: return, throw 以及堆栈。但是想要 promises 能够提供这些便利给你的前提是你知道如何正确的使用它们。</p>
<h2 id="新手错误"><a href="#新手错误" class="headerlink" title="新手错误"></a>新手错误</h2><p>Promise对于不同的人有不同的理解和观点，但是这篇文章我特质<a href="https://promisesaplus.com/" target="_blank" rel="external">正式标准</a>, 在现代浏览器中暴露为window.Promise。虽然并非所有浏览器都有windows.Promise,但是可以寻找一些pollyfill,比如<a href="https://github.com/calvinmetcalf/lie" target="_blank" rel="external">Lie</a>、<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a>。</p>
<h3 id="新手错误-1：-promise版的金字塔问题"><a href="#新手错误-1：-promise版的金字塔问题" class="headerlink" title="新手错误 #1： promise版的金字塔问题"></a>新手错误 #1： promise版的金字塔问题</h3><p>观察大家如何使用 PouchDB 这类大型的 promise 风格的API，我发现大量错误的 promise 使用形式。最常见的错误就是下面这个:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">remotedb.allDocs(&#123;</div><div class="line">    <span class="attr">include_docs</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">attachments</span>: <span class="literal">true</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> docs = result.rows;</div><div class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">            alert(<span class="string">'Pulled doc with id '</span> + element.doc._id + <span class="string">' and added to local db.'</span>);</div><div class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (err.status == <span class="number">409</span>) &#123;</div><div class="line">                localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</div><div class="line">                    localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</div><div class="line">                            <span class="comment">// et cetera...</span></div><div class="line">                    &#125;)</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>是的，实际上你可以像使用回调一样使用 promises，恩，就像用打磨机去削脚趾甲一样，你确实可以这么做。</p>
<p>并且如果你以为这样的错误只限于初学者，那么你会惊讶于我实际上是在黑莓官方开发者博客上看到上面的代码。老的回调风格的习惯难以消灭。(至开发者: 抱歉选了你的例子，但是你的例子将会有积极的教育意义)</p>
<p>正确的风格应该是:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfAllDocs</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> localdb.put(...)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> localdb.get(...)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> localdb.put(...)</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用，稍后我们在这块做更多的讨论。</p>
<h3 id="新手错误-2：-WTF-用了-promises-后怎么用-forEach"><a href="#新手错误-2：-WTF-用了-promises-后怎么用-forEach" class="headerlink" title="新手错误 #2： WTF, 用了 promises 后怎么用 forEach?"></a>新手错误 #2： WTF, 用了 promises 后怎么用 forEach?</h3><p>这里是大多数人对于 promises 的理解开始出现偏差。一旦当他们要使用他们熟悉的 forEach() 循环 (无论是 for 循环还是 while 循环)，他们完全不知道如何将 promises 与其一起使。因此他们就会写下类似这样的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// I want to remove() all docs</span></div><div class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</div><div class="line">        db.remove(row.doc)</div><div class="line">    &#125;)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// I naively believe all docs have been removed() now!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这份代码有什么问题？问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！</p>
<p>这是一个非常隐蔽的 bug，因为如果 PouchDB 删除这些文档足够快，你的 UI 界面上显示的会完成正常，你可能会完全注意不到有什么东西有错误。这个 bug 可能会在一些古怪的竞态问题或一些特定的浏览器中暴露出来，并且到时可能几乎没有可能去定位问题。</p>
<p>简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.allDocs(&#123;<span class="attr">include_docs</span>: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> db.remove(row.doc)</div><div class="line">    &#125;))</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</div><div class="line">    <span class="comment">// All docs have really been removed() now!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。</p>
<p>并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。</p>
<h3 id="新手错误-3：-忘记使用-catch"><a href="#新手错误-3：-忘记使用-catch" class="headerlink" title="新手错误 #3： 忘记使用 .catch()"></a>新手错误 #3： 忘记使用 .catch()</h3><p>这是另一个常见的错误。单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。</p>
<blockquote>
<p>类似 Bluebird 之类的 Promise 库会在这种场景抛出 UnhandledRejectionError 警示有未处理的异常，这类情况一旦发现，就会造成脚本异常，在 Node 中更会造成进程 Crash 的问题，因此正确的添加 .catch() 非常重要。 译者注</p>
</blockquote>
<p>为了避免这类讨厌的场景，我习惯于像下面的代码一样使用 promise:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> anotherPromise();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> yetAnotherPromise();</div><div class="line">&#125;).catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></div></pre></td></tr></table></figure>
<p>即使你坚信不会出现异常，添加一个 catch() 总归是更加谨慎的。如果你的假设最终被发现是错误的，它会让你的生活更加美好。</p>
<h3 id="新手错误-4：使用-“deferred”"><a href="#新手错误-4：使用-“deferred”" class="headerlink" title="新手错误 #4：使用 “deferred”"></a>新手错误 #4：使用 “deferred”</h3><p>这是一个我经常可以看到的错误，以至于我甚至不愿意在这里重复它，就像惧怕 Beetlejuice 一样，仅仅是提到它的名字，就会召唤出来更多。</p>
<p>简单的说，promises 拥有一个漫长并且戏剧化的历史，Javascript 社区花费了大量的时间让其走上正轨。在早期，deferred 在 Q，When，RSVP，Bluebird，Lie等等的 “优秀” 类库中被引入， jQuery 与 Angular 在使用 ES6 Promise 规范之前，都是使用这种模式编写代码。</p>
<p>因此如果你在你的代码中使用了这个词 (我不会把这个词重复第三遍！)，你就做错了。下面是说明一下如何避免它。</p>
<p>首先，大部分 promises 类库都会提供一个方式去包装一个第三方的 promises 对象。举例来说，Angular的 $q 模块允许你使用 $q.when 包裹非 $q 的 promises。因此 Angular 用户可以这样使用 PouchDB promises.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$q.when(db.put(doc)).then(<span class="comment">/* ... */</span>); <span class="comment">// &lt;-- this is all the code you need</span></div></pre></td></tr></table></figure>
<p>另一种策略是使用<a href="https://blog.domenic.me/the-revealing-constructor-pattern/" target="_blank" rel="external">构造函数声明模式</a>，它在用来包裹非 promise API 时非常有用。举例来说，为了包裹一个回调风格的 API 如 Node 的 fs.readFile ，你可以简单的这么做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">return</span> reject(err);</div><div class="line">        &#125;</div><div class="line">        resolve(file);</div><div class="line">    &#125;);</div><div class="line">&#125;).then(<span class="comment">/* ... */</span>)</div></pre></td></tr></table></figure>
<p>完工！我们打败了可怕的 def….啊哈，抓到自己了。:)</p>
<blockquote>
<p>关于为何这是一种反模式更多的内容，请查看 Bluebird 的 <a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="external">promise anti-patterns</a> wiki 页</p>
</blockquote>
<h3 id="新手错误-5：使用副作用调用而非返回"><a href="#新手错误-5：使用副作用调用而非返回" class="headerlink" title="新手错误 #5：使用副作用调用而非返回"></a>新手错误 #5：使用副作用调用而非返回</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    someOtherPromise()</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Gee, I hope someOtherPromise() has resolved!</span></div><div class="line">    <span class="comment">// Spoiler alert: it hasn't.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>好了，现在是时候讨论一下关于 promises 你所需要知道的一切。</p>
<p>认真的说，这是一个一旦你理解了它，就会避免所有我提及的错误的古怪的技巧。你准备好了么？</p>
<p>就如我前面所说，promises 的奇妙在于给予我们以前的 return 与 throw。但是在实践中这到底是怎么一回事呢？</p>
<p>每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, …) 的语法糖)。当我们在 then() 函数内部时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// I'm inside a then() function!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>我们可以做什么呢？有三种事情：</p>
<p>return 另一个 promise<br>return 一个同步的值 (或者 undefined)<br>throw 一个同步异常<br>就是这样。一旦你理解了这个技巧，你就理解了 promises。因此让我们逐个了解下。</p>
<p>返回另一个 promise<br>这是一个在 promise 文档中常见的使用模式，也就是我们在上文中提到的 “composing promises”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// I got a user account!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>注意到我是 <code>return</code> 第二个 promise，这个 <code>return</code> 非常重要。如果我没有写 <code>return</code>，<code>getUserAccountById()</code> 就会成为一个副作用，并且下一个函数将会接收到 <code>undefined</code> 而非 <code>userAccount</code>。</p>
</blockquote>
<h3 id="返回一个同步值-或者-undefined"><a href="#返回一个同步值-或者-undefined" class="headerlink" title="返回一个同步值 (或者 undefined)"></a>返回一个同步值 (或者 undefined)</h3><p>返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</div><div class="line">        <span class="keyword">return</span> inMemoryCache[user.id]    <span class="comment">// returning a synchronous value!</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id) <span class="comment">// returning a promise!</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// I got a user account!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>是不是很赞？第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。</p>
<p>不幸的是，有一个不便的现实是在 JavaScript 中无返回值函数在技术上是返回 undefined，这就意味着当你本意是返回某些值时，你很容易会不经意间引入副作用。</p>
<p>出于这个原因，我个人养成了在 then() 函数内部 永远返回或抛出 的习惯。我建议你也这样做。</p>
<h3 id="抛出同步异常"><a href="#抛出同步异常" class="headerlink" title="抛出同步异常"></a>抛出同步异常</h3><p>谈到 throw，这是让 promises 更加赞的一点。比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (user.isLoggedOut()) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>) <span class="comment">// throwing a synchronous error!</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</div><div class="line">        <span class="keyword">return</span> inMemoryCache[user.id]       <span class="comment">// returning a synchronous value!</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id)   <span class="comment">// returning a promise!</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// I got a user account!</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// Boo, I got an error!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。</p>
<p>这种特性非常有用，因此它能够在开发过程中帮助定位代码问题。举例来说，如果在 then() 函数内部中的任何地方，我们执行 JSON.parse()，如果 JSON 格式是错误的，那么它就会抛出一个异常。如果是使用回调风格，这个错误很可能就会被吃掉，但是使用 promises，我们可以轻易的在 catch() 函数中处理它了。</p>
<h1 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h1><p>好了，现在你已经了解了让 promises 变的超级简单的技巧，现在让我们聊一聊一些特殊场景。<br>这些错误之所以被我归类为 “进阶” ，是因为我只见过这些错误发生在对 promises 已经有相当深入了解的开发者身上。但是为了解决文章最开始的谜题，我们必须讨论一下这些错误。</p>
<h3 id="进阶错误-1：不知道-Promise-resolve"><a href="#进阶错误-1：不知道-Promise-resolve" class="headerlink" title="进阶错误 #1：不知道 Promise.resolve()"></a>进阶错误 #1：不知道 Promise.resolve()</h3><p>如我上面所列举的，promises 在封装同步与异步代码时非常的有用。然而，如果你发现你经常写出下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(someSynchronousValue)</div><div class="line">&#125;).then(<span class="comment">/* ... */</span>)</div></pre></td></tr></table></figure>
<p>你会发现使用 Promise.resolve 会更加简洁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(someSynchronousValue).then(<span class="comment">/* ... */</span>);</div></pre></td></tr></table></figure>
<p>它在用来捕获同步异常时也极其的好用。由于它实在是好用，因此我已经养成了在我所有 promise 形式的 API 接口中这样使用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        doSomethingThatMayThrow()</div><div class="line">        <span class="keyword">return</span> <span class="string">'foo'</span></div><div class="line">    &#125;).then(<span class="comment">/* ... */</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>切记：任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。</p>
<p>类似的，还有 Promise.reject() 你可以用来返回一个立刻返回失败的 promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</div></pre></td></tr></table></figure>
<h3 id="进阶错误-2：catch-与-then-null-…-并非完全等价"><a href="#进阶错误-2：catch-与-then-null-…-并非完全等价" class="headerlink" title="进阶错误 #2：catch() 与 then(null, …) 并非完全等价"></a>进阶错误 #2：catch() 与 then(null, …) 并非完全等价</h3><p>之前我说过 catch() 仅仅是一个语法糖。因此下面两段代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然而，这并不意味着下面两段代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> someOtherPromise();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> someOtherPromise();</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果你好奇为何这两段代码并不等价，可以考虑一下如果第一个函数抛出异常会发生什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>)</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// I caught your error! :)</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// I didn't catch your error! :(</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>因此，当你使用 then(resolveHandler, rejectHandler) 这种形式时，rejectHandler 并不会捕获由 resolveHandler 引发的异常。</p>
<p>鉴于此，我个人的习惯是不适用 then() 的第二个参数，而是总是使用 catch()。唯一的例外是当我写一些异步的 Mocha 测试用例时，我可能会希望用例的异常可以正确的被抛出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> doSomethingThatThrows().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>)</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        should.exist(err)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>说到这里，<a href="http://mochajs.org/" target="_blank" rel="external">Mocha</a> 和 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a> 用来测试 promise 接口时，是一对非常好的组合。 <a href="https://github.com/pouchdb/plugin-seed" target="_blank" rel="external">pouchdb-plugin-seed</a> 项目中有一些 <a href="https://github.com/pouchdb/plugin-seed/blob/master/test/test.js" target="_blank" rel="external">示例</a> 可以帮助你入门。</p>
<h3 id="进阶错误-3：promises-vs-promises-factories"><a href="#进阶错误-3：promises-vs-promises-factories" class="headerlink" title="进阶错误 #3：promises vs promises factories"></a>进阶错误 #3：promises vs promises factories</h3><p>当我们希望执行一个个的执行一个 promises 序列，即类似 Promise.all() 但是并非并行的执行所有 promises。</p>
<p>你可能天真的写下这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve()</div><div class="line">    promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</div><div class="line">        result = result.then(promise)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不幸的是，这份代码不会按照你的期望去执行，你传入 executeSequentially() 的 promises 依然会并行执行。</p>
<p>其根源在于你所希望的，实际上根本不是去执行一个 promises 序列。依照 promises 规范，一旦一个 promise 被创建，它就被执行了。因此你实际上需要的是一个 promise factories 数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve()</div><div class="line">    promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</div><div class="line">        result = result.then(promiseFactory)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我知道你在想什么：“这是哪个见鬼的 Java 程序猿，他为啥在说 factories？” 。实际上，一个 promises factory 是十分简单的，它仅仅是一个可以返回 promise 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> somethingThatCreatesAPromise();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为何这样就可以了？这是因为一个 promise factory 在被执行之前并不会创建 promise。它就像一个 then 函数一样，而实际上，它们就是完全一样的东西。</p>
<p>如果你查看上面的 executeSequentially() 函数，然后想象 myPromiseFactory 被包裹在 result.then(…) 之中，也许你脑中的小灯泡就会亮起。在此时此刻，对于 promise 你就算是悟道了。</p>
<h3 id="进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办"><a href="#进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办" class="headerlink" title="进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办"></a>进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办</h3><p>有时候，一个 promise 会依赖于另一个，但是如果我们希望同时获得这两个 promises 的输出。举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// dangit, I need the "user" object too!</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>为了成为一个优秀的 Javascript 开发者，并且避免金字塔问题，我们可能会将 user 对象存在一个更高的作用域中的变量里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user</div><div class="line">getUserByName(<span class="string">'nolan'</span>)</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    user = result</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样是没问题的，但是我个人认为这样做有些杂牌。我推荐的策略是抛弃成见，拥抱金字塔：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">        <span class="comment">// okay, I have both the "user" and the "userAccount"</span></div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>…至少暂时这样是没问题的。一旦缩进开始成为问题，你可以通过 Javascript 开发者从远古时期就开始使用的技巧，将函数抽离到一个命名函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> doSomething(user, userAccount)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserByName(<span class="string">'nolan'</span>)</div><div class="line">.then(onGetUser)</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>由于你的 promise 代码开始变得更加复杂，你可能发现自己开始将越来越多的函数抽离到命名函数中，我发现这样做，你的代码会越来越漂亮，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">putYourRightFootIn()</div><div class="line">.then(putYourRightFootOut)</div><div class="line">.then(putYourRightFootIn)</div><div class="line">.then(shakeItAllAbout)</div></pre></td></tr></table></figure>
<p><code>这就是 promises 的重点。</code></p>
<h3 id="进阶错误-5：promises-穿透"><a href="#进阶错误-5：promises-穿透" class="headerlink" title="进阶错误 #5：promises 穿透"></a>进阶错误 #5：promises 穿透</h3><p>最后，这个错误就是我开头说的 promises 谜题所影射的错误。这是一个非常稀有的用例，并且可能完全不会出现在你的代码中，但是的的确确震惊了我。</p>
<p>你认为下面的代码会打印出什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line">.then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果你认为它会打印出 bar，那么你就错了。它实际上打印出来的是 foo！</p>
<p>发生这个的原因是如果你像 then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。你可以自己测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line">.then(<span class="literal">null</span>)</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>添加任意数量的 then(null)，它依然会打印 foo。</p>
<p>这实际上又回到了我之前说的 promises vs promise factories。简单的说，你可以直接传递一个 promise 到 then() 函数中，但是它并不会按照你期望的去执行。then() 是期望获取一个函数，因此你希望做的最可能是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(result)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这样他就会如我们所想的打印出 bar。</p>
<p><code>因此记住：永远都是往 then() 中传递函数！</code></p>
<h3 id="期待-async-await"><a href="#期待-async-await" class="headerlink" title="期待 async/await"></a>期待 async/await</h3><p>在 “<a href="https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html" target="_blank" rel="external">Taming the asynchronous beast with ES7</a>” 中提到的重点，在这篇文章中我探究了 ES7 的 async/await 关键字，以及它们是如何将 promises 更深度的结合入语言。不再会要求我们去编写伪同步的代码（以及一个假的 catch() 函数，虽然像，但是并非是 catch），ES7 将会允许我们使用真正的 try/catch/return 关键字，就像我们在 CS 101 上学的一样。</p>
<p>这对于 Javascript 语言来说是一个大福音。因为即使到最后，只要我们的工具不告诉我们做错了，这些 promise 反模式依然会一直出现。</p>
<p>从 JavaScript 的历史来看，我认为公正的评价来说 JSLint 与 JSHint 对社区的贡献是高于 JavaScript: The Good Parts 的，虽然他们包含的信息实际上是相同的。但是它们的区别在于 被告知你在你代码中犯的错误 与你去阅读一本书籍，去理解其他人犯的错误。</p>
<p>ES7 的 async/await 的美妙在于，你的错误会被作为语法或者编译器错误提示出来，而不是运行时的 bug。不过就目前而言，了解 promise 可以做什么以及如何在 ES5 与 ES6 中正确的使用它们依然是有必要的。</p>
<p>因此当我意识到，就像 JavaScript: The Good Parts 一样，这篇博文可能只会有非常有限的影响的时候，我希望当你发现其他人在犯同样的错误的时候，你可以将这篇博文提供给他们。因为现在依然有很多同学需要承认: “I have a problem with promises!”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Promise.all is good for executing many promises at once</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  promise1,</div><div class="line">  promise2</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="comment">// Promise.resolve is good for wrapping synchronous code</span></div><div class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (somethingIsNotRight()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"I will be rejected asynchronously!"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"This string will be resolved asynchronously!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// execute some promises one after the other.</span></div><div class="line"><span class="comment">// this takes an array of promise factories, i.e.</span></div><div class="line"><span class="comment">// an array of functions that RETURN a promise</span></div><div class="line"><span class="comment">// (not an array of promises themselves; those would execute immediately)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequentialize</span>(<span class="params">promiseFactories</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> chain = <span class="built_in">Promise</span>.resolve();</div><div class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</div><div class="line">    chain = chain.then(promiseFactory);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> chain;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Promise.race is good for setting a timeout:</span></div><div class="line"><span class="built_in">Promise</span>.race([</div><div class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(reject, <span class="number">10000</span>); <span class="comment">// timeout after 10 secs</span></div><div class="line">  &#125;),</div><div class="line">  doSomethingThatMayTakeAwhile()</div><div class="line">]);</div><div class="line"></div><div class="line"><span class="comment">// Promise finally util similar to Q.finally</span></div><div class="line"><span class="comment">// e.g. promise.then(...).catch().then(...).finally(...)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finally</span> (<span class="params">promise, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> promise2 = cb();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> promise2 = cb();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise2.then === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> promise2.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> reason;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> reason;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/12/05/jekyll-github-page-travis-ci/" data-toggle="tooltip" data-placement="top" title="Jekyll + Github pages + Travis">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/07/04/frontend-module-definition/" data-toggle="tooltip" data-placement="top" title="AMD CDM COMMONJS">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Promise" title="Promise">Promise</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://blog.kaijun.rocks" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="http://huangxuan.me" target="_blank">Hux Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "blog-asherjia-com";
    var disqus_identifier = "http://blog.asherjia.com/2016/07/04/we-have-a-problem-with-promise/";
    var disqus_url = "http://blog.asherjia.com/2016/07/04/we-have-a-problem-with-promise/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/asherjia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/asherjia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/asherjia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/asherjia">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Asher&#39;s Blog 2017 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://blog.asherjia.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="http://blog.asherjia.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
