{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/tag-bg.jpg","path":"img/tag-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/home-bg-o.jpg","path":"img/home-bg-o.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/css/hux-blog.css","path":"css/hux-blog.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"themes/huxblog/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huxblog/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/huxblog/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495870312000},{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1495870312000},{"_id":"themes/huxblog/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1495870312000},{"_id":"themes/huxblog/_config.yml","hash":"78c57a69155be39d8e91d3ad8cb8d0367760d7f6","modified":1495871216000},{"_id":"themes/huxblog/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1495870767000},{"_id":"source/_posts/IMAPOST.md","hash":"0a7df0dab77add3b0f92b1ba131d9fa32cced14f","modified":1495870543000},{"_id":"source/_posts/hello-2015.markdown","hash":"999910c6056e2f2d680e668fac2621db196cf7c0","modified":1495870312000},{"_id":"source/_posts/js-module-loader.markdown","hash":"a9bb15f756fed8464a52a5f7131336b27715a34d","modified":1495870312000},{"_id":"source/_posts/js-module-7day.markdown","hash":"e2ad67488d6e38c6844a7203f8c89918847c221f","modified":1495870312000},{"_id":"source/_posts/2017-03-06-we-have-a-problem-with-promise.markdown","hash":"2c2480130361b2d552342e11f01751dc02930b3d","modified":1495849829000},{"_id":"source/_posts/js-version.markdown","hash":"325424f7d638c817164b8e977ba2ef2b18876444","modified":1495870312000},{"_id":"source/_posts/unix-linux-note.markdown","hash":"4f9eefe870a1291f469eef2b2603357c3f1da924","modified":1495870312000},{"_id":"source/archives/index.md","hash":"f30bcd9cd0fbe690c2398f21dbf27e56c0c72499","modified":1495870312000},{"_id":"source/about/index.md","hash":"900b72df10ceb5337e4be7bbb51d077a2b901ba4","modified":1495870312000},{"_id":"source/img/avatar.jpg","hash":"49cfa597392c4a116584c07690efbbc06354acc7","modified":1495870312000},{"_id":"source/img/favicon.ico","hash":"a8ee7712f6560180efccb68546de6ea0d937fff3","modified":1495870312000},{"_id":"source/img/icon_wechat.png","hash":"7fdb00c9017236e05c1b3e6da38a2cc382fd69fa","modified":1495870312000},{"_id":"source/tags/index.md","hash":"0bc541f4c6a0f21bec67b6717ee86226f0eddf39","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1495870312000},{"_id":"themes/huxblog/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1495870312000},{"_id":"themes/huxblog/layout/archive.ejs","hash":"6c3ed5d914379319efe835a4aa505abbc616c328","modified":1495870312000},{"_id":"themes/huxblog/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1495870312000},{"_id":"themes/huxblog/layout/about.ejs","hash":"7f56c71383ef6c156b56d79b3984e07cc466606a","modified":1495870312000},{"_id":"themes/huxblog/layout/index.ejs","hash":"70ac58c46625300a70791e210daf446afa6d1cd4","modified":1495870312000},{"_id":"themes/huxblog/layout/page.ejs","hash":"3fde0787e883274563f9de5aaeb8130b667e132a","modified":1495870312000},{"_id":"themes/huxblog/layout/archives.ejs","hash":"f0046e58cc1dd876133be2bf927aed2b1821cb3e","modified":1495870312000},{"_id":"themes/huxblog/layout/post.ejs","hash":"fd68124c3de2bbe7d870cecadcf684df7cf82519","modified":1495870312000},{"_id":"themes/huxblog/layout/tags.ejs","hash":"a51bf2828af20939d702de1fdae067439a1153c0","modified":1495870312000},{"_id":"themes/huxblog/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1495870312000},{"_id":"themes/huxblog/layout/layout.ejs","hash":"03e278a3b8bc4503183276b6130ac04a8d5b9865","modified":1495870312000},{"_id":"source/img/tag-bg.jpg","hash":"8844274a812ae19e8f2a3b7e4e465342e63eb852","modified":1495870312000},{"_id":"source/_posts/js-version/keep-calm-and-learn-javascript.png","hash":"49ea101b92ce5e136a19e6b11162f8f4126fe01f","modified":1495870312000},{"_id":"source/_posts/js-version/post-bg-js-version.jpg","hash":"1598a1180c491f36b9036415b622bd9e5ad5d3bc","modified":1495870312000},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1495870312000},{"_id":"source/img/home-bg-o.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1495870312000},{"_id":"themes/huxblog/layout/_partial/head.ejs","hash":"87c544a64ea49b835330135a616deb2e9fd39bbb","modified":1495870312000},{"_id":"themes/huxblog/layout/_partial/footer.ejs","hash":"e325a9953abc1a3751aa1a927bc3ecbdd627803a","modified":1495870312000},{"_id":"themes/huxblog/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1495870312000},{"_id":"themes/huxblog/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1495870312000},{"_id":"themes/huxblog/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1495870312000},{"_id":"themes/huxblog/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1495870312000},{"_id":"themes/huxblog/source/css/hux-blog.css","hash":"c1b0a32ad8075ac09d99fb4d64a9fbc84163abf8","modified":1495870312000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1495870312000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1495870312000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1495870312000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1495870312000},{"_id":"themes/huxblog/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1495870312000},{"_id":"themes/huxblog/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1495870312000},{"_id":"themes/huxblog/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1495870312000},{"_id":"themes/huxblog/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1495870312000},{"_id":"themes/huxblog/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1495870312000},{"_id":"source/_posts/js-module-loader/post-bg-js-module.jpg","hash":"4a43bfa6b69c79a6ef90bd852fe5756d241733cd","modified":1495870312000},{"_id":"source/img/home-bg.jpg","hash":"a191201c3a98728e6ea66d6827df827ecfcc9d33","modified":1495870312000},{"_id":"source/_posts/js-version/javascript-java.jpg","hash":"881e35e241a8be40f3c4e3a6f57d5402247c1eb3","modified":1495870312000},{"_id":"source/_posts/unix-linux-note/post-bg-unix-linux.jpg","hash":"e8f3739cb78ea6d1645665d07ebdb79881774fb6","modified":1495870312000},{"_id":"themes/huxblog/source/css/bootstrap.min.css","hash":"973e37a8502921d56bc02bb55321f45b072b6f71","modified":1495870312000},{"_id":"themes/huxblog/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1495870312000},{"_id":"themes/huxblog/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1495870312000},{"_id":"themes/huxblog/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1495870312000},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1495870312000},{"_id":"themes/huxblog/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1495870312000},{"_id":"source/_posts/hello-2015/post-bg-2015.jpg","hash":"7118d1af8ac638dc55ee63d0b17e704811c6a37a","modified":1495870312000},{"_id":"themes/huxblog/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1495870312000},{"_id":"source/img/about-bg.jpg","hash":"b5814b2d10eb38dfda0072365567f3823bc34aba","modified":1495870312000},{"_id":"source/news/index.md","hash":"7d6cb7f4c29d7b3594033ac1a310a4bcb9f7d1b8","modified":1495871165000}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2017-05-27T07:31:52.000Z","updated":"2017-05-27T07:31:52.000Z","path":"404.html","title":"","comments":1,"_id":"cj36yug990000wkt7o53wxy6r","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archives","title":"Archives","description":"Hey, this is Archives.","header-img":"img/tag-bg.jpg","_content":"","source":"archives/index.md","raw":"---\nlayout: \"archives\"\ntitle: \"Archives\"\ndescription: \"Hey, this is Archives.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-05-27T07:31:52.000Z","updated":"2017-05-27T07:31:52.000Z","path":"archives/index.html","comments":1,"_id":"cj36yuga40002wkt7yj8pz2sa","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T20:48:33.000Z","description":"Hey, this is Kaijun.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Hey, this is Kaijun.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n\n>写写代码，做做设计，看看产品。\n>世界那么大，多玩玩看看。\n\n9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br>\n<br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。\n\n<p style=\"text-align:right;\">\n    —— <a href=\"http://www.zhihu.com/question/19687065\">李书航 － 什么是「共产中文腔调」？ </a>\n</p>","updated":"2017-05-27T07:31:52.000Z","path":"about/index.html","_id":"cj36yuga80004wkt7wuzaamf3","content":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"external\">李书航 － 什么是「共产中文腔调」？ </a><br></p>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>写写代码，做做设计，看看产品。<br>世界那么大，多玩玩看看。</p>\n</blockquote>\n<p>9月21日上午，阳光明媚，鲜花斗艳。帕洛阿尔托苹果店里欢声笑语，人头攒动。苹果公司首席执行官蒂姆·库克先生在店长欧阳猛南陪同下，不远千米，深入到一线店面，为那里的员工带去节曰的问候和良好的祝愿。<br><br>“果粉们，你们辛苦了，我代表某果公司，祝你们身体健康，生活幸福，工作成功！”库克亲切慰问广大员工和顾客，并就iOS7、iPhone 5S和iPhone 5C的销售状况进行调研。 <br><br>“您现在每月工资有多少？肾5S拿到了吗？”在店里，库克关切地向果粉们问起这一问题。当听说果粉们排到了5S，库克满意地连连点头。接着他指出，近年来苹果事业发展取得巨大成就，特别是iPhone影响剧增，老百姓对iOS满意度逐步提高，在这个转变过程中，果粉的辛勤工作功不可没。<br><br>库克看到一个中国小朋友在排队买iPhone 5S，亲切的问：“5288元一台能承受不？”小朋友回答到：“能！”当得知这位小朋友卖了一个肾来买iPhone 5S时，库克叮嘱道：“在支持苹果的同时，也要爱护身体。”<br><br>库克与购买苹果手机的果粉们兴致勃勃地参观了苹果专卖店，和员工们拉了拉家常，并饶有兴趣地玩了四盘切西瓜游戏，与普通员工同乐。<br><br>在交谈中，库克多次关心地强调：“有了iPhone 5C，就不卖iPhone 5了。”并对顾客说：“好好休息，身体是革命的本钱嘛！”会谈始终在亲切友好的气氛中进行。<br><br>顾客们就库克的讲话达成了广泛的共识，并承认世界上只有iOS最流畅，要紧紧的团结在以库克先生为首席执行官的苹果公司集体周围，一心一意抓学习，聚精会神谋发展。<br><br><br>帕洛阿尔托苹果专卖店当日原则通过《蒂姆·库克首席执行官在加州新苹果店的讲话纪要》，并下发各分店认真学习、研讨。</p>\n<p style=\"text-align:right;\"><br>    —— <a href=\"http://www.zhihu.com/question/19687065\" target=\"_blank\" rel=\"external\">李书航 － 什么是「共产中文腔调」？ </a><br></p>"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/tag-bg.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/tag-bg.jpg\"\n---\n","date":"2017-05-27T07:31:52.000Z","updated":"2017-05-27T07:31:52.000Z","path":"tags/index.html","comments":1,"_id":"cj36yugac0006wkt7d85lzu2u","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"news","title":"News","description":"Hey, this is Kaijun.","header-img":"img/about-bg.jpg","comments":1,"_content":"\n# News","source":"news/index.md","raw":"---\nlayout: \"news\"\ntitle: \"News\"\ndescription: \"Hey, this is Kaijun.\"\nheader-img: \"img/about-bg.jpg\"\ncomments: true\n---\n\n# News","date":"2017-05-27T07:46:05.000Z","updated":"2017-05-27T07:46:05.000Z","path":"news/index.html","_id":"cj36z0q9f0000zqt7s6tt1jyo","content":"<h1 id=\"News\"><a href=\"#News\" class=\"headerlink\" title=\"News\"></a>News</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"News\"><a href=\"#News\" class=\"headerlink\" title=\"News\"></a>News</h1>"}],"Post":[{"title":"IMAPOST","date":"2017-05-27T07:35:43.000Z","_content":"","source":"_posts/IMAPOST.md","raw":"---\ntitle: IMAPOST\ndate: 2017-05-27 15:35:43\ntags:\n---\n","slug":"IMAPOST","published":1,"updated":"2017-05-27T07:35:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj36yuga00001wkt7l4c19rjd","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"post","title":"Welcome to Hux Blog","subtitle":" \"Hello World, Hello Blog\"","date":"2014-01-29T04:00:00.000Z","author":"Hux","header-img":"post-bg-2015.jpg","_content":"\n> “Yeah It's on. ”\n\n\n## 前言\n\nHux 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2015 年，Hux 总算有个地方可以好好写点东西了。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的[个人网站](http://huangxuan.me/portfolio)是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！\n\n\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\n正好之前就有关注过 [GitHub Pages](https://pages.github.com/) + [Jekyll](http://jekyllrb.com/) 快速 Building Blog 的技术方案，非常轻松时尚。\n\n其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n\t* 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n* Jekyll 的自定制非常容易，基本就是个模版引擎\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。\n\n\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手\n\n大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）\n\n本地调试环境需要 `gem install jekyll`，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功\n\nTheme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），**不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……**所以为了体验，也补了不少 CSS 进去\n\n最后就进入了耗时反而最长的**做图、写字**阶段，也算是进入了**写博客**的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。\n\n第二天考虑中文字体的渲染，fork 了 [Type is Beautiful](http://www.typeisbeautiful.com/) 的 `font` CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。\n\n\n## 后记\n\n回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。\n\n在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。\n\n如果你恰好逛到了这里，希望你也能喜欢这个博客主题。\n\n—— Hux 后记于 2015.10\n","source":"_posts/hello-2015.markdown","raw":"---\nlayout:     post\ntitle:      \"Welcome to Hux Blog\"\nsubtitle:   \" \\\"Hello World, Hello Blog\\\"\"\ndate:       2014-01-29 12:00:00\nauthor:     \"Hux\"\nheader-img: \"post-bg-2015.jpg\"\ntags:\n    - 生活\n---\n\n> “Yeah It's on. ”\n\n\n## 前言\n\nHux 的 Blog 就这么开通了。\n\n[跳过废话，直接看技术实现 ](#build)\n\n\n\n2015 年，Hux 总算有个地方可以好好写点东西了。\n\n\n作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。\n\n在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的[个人网站](http://huangxuan.me/portfolio)是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！\n\n\n<p id = \"build\"></p>\n---\n\n## 正文\n\n接下来说说搭建这个博客的技术细节。  \n\n正好之前就有关注过 [GitHub Pages](https://pages.github.com/) + [Jekyll](http://jekyllrb.com/) 快速 Building Blog 的技术方案，非常轻松时尚。\n\n其优点非常明显：\n\n* **Markdown** 带来的优雅写作体验\n* 非常熟悉的 Git workflow ，**Git Commit 即 Blog Post**\n* 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机\n\t* 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了\n* Jekyll 的自定制非常容易，基本就是个模版引擎\n\n\n本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个[镜像](http://huxpro.gitcafe.io)出来，结果还是巨慢。\n\n哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 **pending 在了 Google Fonts** 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。  \n忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。\n\n\n\n---\n\n配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手\n\n大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）\n\n本地调试环境需要 `gem install jekyll`，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功\n\nTheme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），**不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……**所以为了体验，也补了不少 CSS 进去\n\n最后就进入了耗时反而最长的**做图、写字**阶段，也算是进入了**写博客**的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。\n\n第二天考虑中文字体的渲染，fork 了 [Type is Beautiful](http://www.typeisbeautiful.com/) 的 `font` CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。\n\n\n## 后记\n\n回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。\n\n在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。\n\n如果你恰好逛到了这里，希望你也能喜欢这个博客主题。\n\n—— Hux 后记于 2015.10\n","slug":"hello-2015","published":1,"updated":"2017-05-27T07:31:52.000Z","comments":1,"photos":[],"link":"","_id":"cj36yuga50003wkt7j9h0v38p","content":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Hux 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2015 年，Hux 总算有个地方可以好好写点东西了。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的<a href=\"http://huangxuan.me/portfolio\" target=\"_blank\" rel=\"external\">个人网站</a>是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>正好之前就有关注过 <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a> + <a href=\"http://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p>\n<p>其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n<li>Jekyll 的自定制非常容易，基本就是个模版引擎</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手</p>\n<p>大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）</p>\n<p>本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功</p>\n<p>Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），<strong>不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……</strong>所以为了体验，也补了不少 CSS 进去</p>\n<p>最后就进入了耗时反而最长的<strong>做图、写字</strong>阶段，也算是进入了<strong>写博客</strong>的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。</p>\n<p>第二天考虑中文字体的渲染，fork 了 <a href=\"http://www.typeisbeautiful.com/\" target=\"_blank\" rel=\"external\">Type is Beautiful</a> 的 <code>font</code> CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。</p>\n<p>在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。</p>\n<p>如果你恰好逛到了这里，希望你也能喜欢这个博客主题。</p>\n<p>—— Hux 后记于 2015.10</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“Yeah It’s on. ”</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Hux 的 Blog 就这么开通了。</p>\n<p><a href=\"#build\">跳过废话，直接看技术实现 </a></p>\n<p>2015 年，Hux 总算有个地方可以好好写点东西了。</p>\n<p>作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。</p>\n<p>在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的<a href=\"http://huangxuan.me/portfolio\" target=\"_blank\" rel=\"external\">个人网站</a>是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><p id=\"build\"></p></h2><h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>\n<p>正好之前就有关注过 <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a> + <a href=\"http://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p>\n<p>其优点非常明显：</p>\n<ul>\n<li><strong>Markdown</strong> 带来的优雅写作体验</li>\n<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>\n<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>\n<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了</li>\n</ul>\n</li>\n<li>Jekyll 的自定制非常容易，基本就是个模版引擎</li>\n</ul>\n<p>本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个<a href=\"http://huxpro.gitcafe.io\" target=\"_blank\" rel=\"external\">镜像</a>出来，结果还是巨慢。</p>\n<p>哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 <strong>pending 在了 Google Fonts</strong> 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。<br>忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。</p>\n<hr>\n<p>配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手</p>\n<p>大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）</p>\n<p>本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功</p>\n<p>Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），<strong>不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……</strong>所以为了体验，也补了不少 CSS 进去</p>\n<p>最后就进入了耗时反而最长的<strong>做图、写字</strong>阶段，也算是进入了<strong>写博客</strong>的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。</p>\n<p>第二天考虑中文字体的渲染，fork 了 <a href=\"http://www.typeisbeautiful.com/\" target=\"_blank\" rel=\"external\">Type is Beautiful</a> 的 <code>font</code> CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。</p>\n<p>在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。</p>\n<p>如果你恰好逛到了这里，希望你也能喜欢这个博客主题。</p>\n<p>—— Hux 后记于 2015.10</p>\n"},{"layout":"post","title":"Example Post with Code Highlight","subtitle":"CommonJS，RequireJS，SeaJS 归纳笔记","date":"2013-05-24T16:00:00.000Z","author":"Hux","catalog":true,"header-img":"post-bg-js-module.jpg","_content":"\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。   \n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> working...\n","source":"_posts/js-module-loader.markdown","raw":"---\nlayout:     post\ntitle:      \"Example Post with Code Highlight\"\nsubtitle:   \"CommonJS，RequireJS，SeaJS 归纳笔记\"\ndate:       2013-05-25\nauthor:     \"Hux\"\ncatalog:    true\nheader-img: \"post-bg-js-module.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n\n\n## Foreword\n\n> Here comes Module!\n\n随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。\n\n于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。\n\n\n---\n\n## Catalog\n\n\n1.  [CommonJS & Node](#commonjs--node)\n3.  [History](#history)\n4.  [RequireJS & AMD](#requirejs--amd)\n5.  [SeaJS & CMD](#seajs--cmd)\n6.  [AMD vs CMD](#amd-vs-cmd)\n7.  [WebPack](#webpack)\n\n\n\n```\nfunction autoDetect(){\n    console.log('ye, it is written in JavaScript!')\n}\n```\n\n## CommonJS & Node\n\n> Javascript: not just for browsers any more! —— CommonJS Slogen\n\n前端模块化的事实标准之一，2009 年 8 月，[CommonJS](http://wiki.commonjs.org/wiki/CommonJS) 诞生。\n\nCommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。\n\n\n让我们看看 Node 中的实现：\n{% codeblock lang:js %}\n// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper\n// \"as though the module was wrapped in a function\"\n\nvar a = require('./a')  // 加载模块（同步加载）\na.doSomething()         // 等上一句执行完才会执行\n\nexports.b = function(){ // 暴露 b 函数接口\n  // do something\n}\n{% endcodeblock %}\n\n\n`exports`是一个内置对象，就像`require`是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写`module.exports`就可以了。\n\nCommonJS 前身叫 ServerJS ，**后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS** 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。\n\n\n因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：\n\n* 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）\n* 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。\n* 都在向着 **COMMON** 的方向进化：**兼容不同风格，兼容浏览器和服务器两种环境**\n\n本文接下来要讨论的典例是：\n\n* RequireJS & AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）\n* SeaJS & CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）\n\n\n\n\n\n## History\n\n<!--<h2 id=\"history\"> History </h2>-->\n\n> 此段落参考自玉伯的 [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)\n\n09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules) 规范，并且在 Node.js 等环境下取得了很不错的实践。\n\n09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n\n1. **Modules/1.x** 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。\n2. **Modules/Async** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 规范及其实现 [RequireJS](http://requirejs.org/)。这个稍后再细说。\n3. **Modules/2.0** 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了\n\n\n补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 `add`和`use` 两个源自于 YUI Modules 的函数名替换了 `define` 和 `require` ，但其原理更接近 RequireJS ，与 YUI Modules 的 `Y` 沙箱 Attach 机制并不相同\n\n\n## RequireJS & AMD\n\n[AMD (Async Module Definition)](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 是 RequireJS 在推广过程中对模块定义的规范化产出。\n\n> RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments\n\nRequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：\n\n{% gist 65481dbbf6d16e831a6cc89c3e37e6e5 display-emails-from-database.php %}\n\n\n> As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?\n\n所以我们需要 **Function Wrapping** 来获取依赖并且提前通过 script tag 提前加载进来\n\n\n{% jsfiddle shorttag [tabs] [skin] [width] [height] %}\n\n\n当依赖模块非常多时，这种**依赖前置**的写法会显得有点奇怪，所以 AMD 给了一个语法糖， **simplified CommonJS wrapping**，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：\n\n```js\ndefine(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\nThe AMD loader will parse out the `require('')` calls by using `Function.prototype.toString()`, then internally convert the above define call into this:\n\n```js\ndefine(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n```\n\n出于`Function.prototype.toString()`兼容性和性能的考虑，最好的做法还是做一次 **optimized build**\n\n\n\nAMD 和 CommonJS 的核心争议如下：\n\n### 1. **执行时机**\n\nModules/1.0:\n\n```js\nvar a = require(\"./a\") // 执行到此时，a.js 才同步下载并执行\n```\n\nAMD: （使用 require 的语法糖时）\n\n```js\ndefine([\"require\"],function(require)){\n    // 在这里，a.js 已经下载并且执行好了\n    // 使用 require() 并不是 AMD 的推荐写法\n    var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n})\n```\n\nAMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）\n\n但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。\n\n### 2. **书写风格**\n\nAMD 推荐的风格并不使用`require`，而是通过参数传入，破坏了**依赖就近**：\n\n```js\ndefine([\"a\", \"b\", \"c\"],function(a, b, c){\n    // 提前申明了并初始化了所有模块\n\n    true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。\n})\n```\n\n不过，在笔者看来，风格喜好因人而异，主要还是**预执行**和**懒执行**的差异。\n\n另外，require 2.0 也开始思考异步处理**软依赖**（区别于一定需要的**硬依赖**）的问题，提出了这样的方案：\n\n```js\n// 函数体内：\nif(status){\n    async(['a'],function(a){\n        a.doSomething()\n    })\n}\n```\n\n## SeaJS & CMD\n\nCMD (Common Module Definition) 是 [SeaJS](http://seajs.org/docs/) 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。\n\n不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。\n\n* CMD Specification\n    * [English (CMDJS-repo)](https://github.com/cmdjs/specification/blob/master/draft/module.md)\n    * [Chinese (SeaJS-repo)](https://github.com/seajs/seajs/issues/242)\n\n\nCMD 主要有 define, factory, require, export 这么几个东西\n\n * define `define(id?, deps?, factory)`\n * factory `factory(require, exports, module)`\n * require `require(id)`\n * exports `Object`\n\n\nCMD 推荐的 Code Style 是使用 CommonJS 风格的 `require`：\n\n* 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已\n\n```js\ndefine(function(require, exports) {\n\n    // 获取模块 a 的接口\n    var a = require('./a');\n    // 调用模块 a 的方法\n    a.doSomething();\n\n    // 对外提供 foo 属性\n    exports.foo = 'bar';\n    // 对外提供 doSomething 方法\n    exports.doSomething = function() {};\n\n});\n```\n\n但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n    // 模块代码...\n\n    // 直接通过 return 暴露接口\n    return {\n        foo: 'bar',\n        doSomething: function() {}\n    };\n\n});\n```\n\n\n\nSea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。\n\n\n\n## AMD vs CMD\n\n**虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：**\n\n1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**懒执行**。（都是先加载）\n*  CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。   \n\n看代码：\n\n```js\n// AMD 默认推荐\n\ndefine(['./a', './b'], function(a, b) {  // 依赖前置，提前执行\n\n    a.doSomething()\n    b.doSomething()\n\n})\n\n```\n\n```js\n// CMD\n\ndefine(function(require, exports, module) {\n\n    var a = require('./a')\n    a.doSomething()\n\n    var b = require('./b') // 依赖就近，延迟执行\n    b.doSomething()\n})\n```\n\n\n\n\n\n\n## WebPack\n\n> working...\n","slug":"js-module-loader","published":1,"updated":"2017-05-27T07:31:52.000Z","comments":1,"photos":[],"link":"","_id":"cj36yugaa0005wkt7mflvilvm","content":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"//jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。   </li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>working…</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Foreword\"><a href=\"#Foreword\" class=\"headerlink\" title=\"Foreword\"></a>Foreword</h2><blockquote>\n<p>Here comes Module!</p>\n</blockquote>\n<p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p>\n<p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p>\n<hr>\n<h2 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h2><ol>\n<li><a href=\"#commonjs--node\">CommonJS &amp; Node</a></li>\n<li><a href=\"#history\">History</a></li>\n<li><a href=\"#requirejs--amd\">RequireJS &amp; AMD</a></li>\n<li><a href=\"#seajs--cmd\">SeaJS &amp; CMD</a></li>\n<li><a href=\"#amd-vs-cmd\">AMD vs CMD</a></li>\n<li><a href=\"#webpack\">WebPack</a></li>\n</ol>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">autoDetect</span>()&#123;</div><div class=\"line\">    console.log('ye, it <span class=\"keyword\">is</span> written <span class=\"keyword\">in</span> JavaScript!')</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CommonJS-amp-Node\"><a href=\"#CommonJS-amp-Node\" class=\"headerlink\" title=\"CommonJS &amp; Node\"></a>CommonJS &amp; Node</h2><blockquote>\n<p>Javascript: not just for browsers any more! —— CommonJS Slogen</p>\n</blockquote>\n<p>前端模块化的事实标准之一，2009 年 8 月，<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS</a> 诞生。</p>\n<p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p>\n<p>让我们看看 Node 中的实现：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class=\"line\"><span class=\"comment\">// \"as though the module was wrapped in a function\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)  <span class=\"comment\">// 加载模块（同步加载）</span></div><div class=\"line\">a.doSomething()         <span class=\"comment\">// 等上一句执行完才会执行</span></div><div class=\"line\"></div><div class=\"line\">exports.b = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// 暴露 b 函数接口</span></div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p>\n<p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p>\n<p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p>\n<ul>\n<li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li>\n<li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li>\n<li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li>\n</ul>\n<p>本文接下来要讨论的典例是：</p>\n<ul>\n<li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li>\n<li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li>\n</ul>\n<h2 id=\"History\"><a href=\"#History\" class=\"headerlink\" title=\"History\"></a>History</h2><!--<h2 id=\"history\"> History </h2>-->\n<blockquote>\n<p>此段落参考自玉伯的 <a href=\"https://github.com/seajs/seajs/issues/588\" target=\"_blank\" rel=\"external\">前端模块化开发那点历史</a></p>\n</blockquote>\n<p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href=\"http://wiki.commonjs.org/wiki/Modules\" target=\"_blank\" rel=\"external\">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p>\n<p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n<ol>\n<li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\" target=\"_blank\" rel=\"external\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li>\n<li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD</a> 规范及其实现 <a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a>。这个稍后再细说。</li>\n<li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li>\n</ol>\n<p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p>\n<h2 id=\"RequireJS-amp-AMD\"><a href=\"#RequireJS-amp-AMD\" class=\"headerlink\" title=\"RequireJS &amp; AMD\"></a>RequireJS &amp; AMD</h2><p><a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\" target=\"_blank\" rel=\"external\">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>\n<blockquote>\n<p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p>\n</blockquote>\n<p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p>\n<script src=\"//gist.github.com/65481dbbf6d16e831a6cc89c3e37e6e5.js?file=display-emails-from-database.php\"></script>\n<blockquote>\n<p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>\n</blockquote>\n<p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p>\n<iframe scrolling=\"no\" width=\"[width]\" height=\"[height]\" src=\"//jsfiddle.net/shorttag/embedded/[tabs]/[skin]\" frameborder=\"0\" allowfullscreen></iframe>\n<p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'require'</span>, <span class=\"string\">'dependency1'</span>, <span class=\"string\">'dependency2'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dependency1 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency1'</span>),</div><div class=\"line\">        dependency2 = <span class=\"built_in\">require</span>(<span class=\"string\">'dependency2'</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p>\n<p>AMD 和 CommonJS 的核心争议如下：</p>\n<h3 id=\"1-执行时机\"><a href=\"#1-执行时机\" class=\"headerlink\" title=\"1. 执行时机\"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure>\n<p>AMD: （使用 require 的语法糖时）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"require\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>))</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 在这里，a.js 已经下载并且执行好了</span></div><div class=\"line\">    <span class=\"comment\">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">\"./a\"</span>) <span class=\"comment\">// 此处仅仅是取模块 a 的 exports</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p>\n<p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p>\n<h3 id=\"2-书写风格\"><a href=\"#2-书写风格\" class=\"headerlink\" title=\"2. 书写风格\"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 提前申明了并初始化了所有模块</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"literal\">true</span> || b.foo(); <span class=\"comment\">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p>\n<p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数体内：</span></div><div class=\"line\"><span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">    <span class=\"keyword\">async</span>([<span class=\"string\">'a'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">        a.doSomething()</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"SeaJS-amp-CMD\"><a href=\"#SeaJS-amp-CMD\" class=\"headerlink\" title=\"SeaJS &amp; CMD\"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href=\"http://seajs.org/docs/\" target=\"_blank\" rel=\"external\">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p>\n<p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p>\n<ul>\n<li>CMD Specification<ul>\n<li><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">English (CMDJS-repo)</a></li>\n<li><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">Chinese (SeaJS-repo)</a></li>\n</ul>\n</li>\n</ul>\n<p>CMD 主要有 define, factory, require, export 这么几个东西</p>\n<ul>\n<li>define <code>define(id?, deps?, factory)</code></li>\n<li>factory <code>factory(require, exports, module)</code></li>\n<li>require <code>require(id)</code></li>\n<li>exports <code>Object</code></li>\n</ul>\n<p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p>\n<ul>\n<li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 获取模块 a 的接口</span></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>);</div><div class=\"line\">    <span class=\"comment\">// 调用模块 a 的方法</span></div><div class=\"line\">    a.doSomething();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对外提供 foo 属性</span></div><div class=\"line\">    exports.foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">    <span class=\"comment\">// 对外提供 doSomething 方法</span></div><div class=\"line\">    exports.doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"string\">'hello'</span>, [<span class=\"string\">'jquery'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 模块代码...</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 直接通过 return 暴露接口</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>,</div><div class=\"line\">        <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p>\n<h2 id=\"AMD-vs-CMD\"><a href=\"#AMD-vs-CMD\" class=\"headerlink\" title=\"AMD vs CMD\"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p>\n<ol>\n<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li>\n</ol>\n<ul>\n<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。   </li>\n</ul>\n<p>看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// AMD 默认推荐</span></div><div class=\"line\"></div><div class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖前置，提前执行</span></div><div class=\"line\"></div><div class=\"line\">    a.doSomething()</div><div class=\"line\">    b.doSomething()</div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD</span></div><div class=\"line\"></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.doSomething()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖就近，延迟执行</span></div><div class=\"line\">    b.doSomething()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"WebPack\"><a href=\"#WebPack\" class=\"headerlink\" title=\"WebPack\"></a>WebPack</h2><blockquote>\n<p>working…</p>\n</blockquote>\n"},{"layout":"keynote","title":"Example Post using Keynote Layout","subtitle":"Keynote: JavaScript Modularization Journey","iframe":"http://huangxuan.me/js-module-7day/","date":"2015-07-08T16:00:00.000Z","author":"Hux","header-img":"post-bg-js-version.jpg","_content":"\n\n> 下滑这里查看更多内容\n\n7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。\n\n于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验\n\n\n### [Watch Slides →](http://huangxuan.me/js-module-7day)\n\n<img src=\"http://huangxuan.me/js-module-7day/attach/qrcode.png\" width=\"350\" height=\"350\"/>\n\n<small class=\"img-hint\">你也可以通过扫描二维码在手机上观看</small>\n\n\n这个 Web Slides 开源在[我的 Github 上](https://github.com/Huxpro/js-module-7day)，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork & pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目\n\n\n### Catalog\n\n- 第一日 上古时期 ***Module?*** 从设计模式说起\n- 第二日 石器时代 ***Script Loader*** 只有封装性可不够，我们还需要加载\n- 第三日 蒸汽朋克 ***Module Loader*** 模块化架构的工业革命\n- 第四日 号角吹响 ***CommonJS*** 征服世界的第一步是跳出浏览器\n- 第五日 双塔奇兵 ***AMD/CMD*** 浏览器环境模块化方案\n- 第六日 精灵宝钻 ***Browserify/Webpack*** 大势所趋，去掉这层包裹！\n- 第七日 王者归来 ***ES6 Module*** 最后的战役\n\n### Thanks\n\n[Reveal.js](http://lab.hakim.se/reveal-js)\n","source":"_posts/js-module-7day.markdown","raw":"---\nlayout:     keynote\ntitle:      \"Example Post using Keynote Layout\"\nsubtitle:   \"Keynote: JavaScript Modularization Journey\"\niframe:     \"http://huangxuan.me/js-module-7day/\"\ndate:       2015-07-09\nauthor:     \"Hux\"\nheader-img: \"post-bg-js-version.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n---\n\n\n> 下滑这里查看更多内容\n\n7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。\n\n于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验\n\n\n### [Watch Slides →](http://huangxuan.me/js-module-7day)\n\n<img src=\"http://huangxuan.me/js-module-7day/attach/qrcode.png\" width=\"350\" height=\"350\"/>\n\n<small class=\"img-hint\">你也可以通过扫描二维码在手机上观看</small>\n\n\n这个 Web Slides 开源在[我的 Github 上](https://github.com/Huxpro/js-module-7day)，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork & pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目\n\n\n### Catalog\n\n- 第一日 上古时期 ***Module?*** 从设计模式说起\n- 第二日 石器时代 ***Script Loader*** 只有封装性可不够，我们还需要加载\n- 第三日 蒸汽朋克 ***Module Loader*** 模块化架构的工业革命\n- 第四日 号角吹响 ***CommonJS*** 征服世界的第一步是跳出浏览器\n- 第五日 双塔奇兵 ***AMD/CMD*** 浏览器环境模块化方案\n- 第六日 精灵宝钻 ***Browserify/Webpack*** 大势所趋，去掉这层包裹！\n- 第七日 王者归来 ***ES6 Module*** 最后的战役\n\n### Thanks\n\n[Reveal.js](http://lab.hakim.se/reveal-js)\n","slug":"js-module-7day","published":1,"updated":"2017-05-27T07:31:52.000Z","comments":1,"photos":[],"link":"","_id":"cj36yugak0008wkt7kh305vys","content":"<blockquote>\n<p>下滑这里查看更多内容</p>\n</blockquote>\n<p>7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。</p>\n<p>于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验</p>\n<h3 id=\"Watch-Slides-→\"><a href=\"#Watch-Slides-→\" class=\"headerlink\" title=\"Watch Slides →\"></a><a href=\"http://huangxuan.me/js-module-7day\" target=\"_blank\" rel=\"external\">Watch Slides →</a></h3><p><img src=\"http://huangxuan.me/js-module-7day/attach/qrcode.png\" width=\"350\" height=\"350\"></p>\n<p><small class=\"img-hint\">你也可以通过扫描二维码在手机上观看</small></p>\n<p>这个 Web Slides 开源在<a href=\"https://github.com/Huxpro/js-module-7day\" target=\"_blank\" rel=\"external\">我的 Github 上</a>，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目</p>\n<h3 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h3><ul>\n<li>第一日 上古时期 <strong><em>Module?</em></strong> 从设计模式说起</li>\n<li>第二日 石器时代 <strong><em>Script Loader</em></strong> 只有封装性可不够，我们还需要加载</li>\n<li>第三日 蒸汽朋克 <strong><em>Module Loader</em></strong> 模块化架构的工业革命</li>\n<li>第四日 号角吹响 <strong><em>CommonJS</em></strong> 征服世界的第一步是跳出浏览器</li>\n<li>第五日 双塔奇兵 <strong><em>AMD/CMD</em></strong> 浏览器环境模块化方案</li>\n<li>第六日 精灵宝钻 <strong><em>Browserify/Webpack</em></strong> 大势所趋，去掉这层包裹！</li>\n<li>第七日 王者归来 <strong><em>ES6 Module</em></strong> 最后的战役</li>\n</ul>\n<h3 id=\"Thanks\"><a href=\"#Thanks\" class=\"headerlink\" title=\"Thanks\"></a>Thanks</h3><p><a href=\"http://lab.hakim.se/reveal-js\" target=\"_blank\" rel=\"external\">Reveal.js</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>下滑这里查看更多内容</p>\n</blockquote>\n<p>7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。</p>\n<p>于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验</p>\n<h3 id=\"Watch-Slides-→\"><a href=\"#Watch-Slides-→\" class=\"headerlink\" title=\"Watch Slides →\"></a><a href=\"http://huangxuan.me/js-module-7day\" target=\"_blank\" rel=\"external\">Watch Slides →</a></h3><p><img src=\"http://huangxuan.me/js-module-7day/attach/qrcode.png\" width=\"350\" height=\"350\"></p>\n<p><small class=\"img-hint\">你也可以通过扫描二维码在手机上观看</small></p>\n<p>这个 Web Slides 开源在<a href=\"https://github.com/Huxpro/js-module-7day\" target=\"_blank\" rel=\"external\">我的 Github 上</a>，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目</p>\n<h3 id=\"Catalog\"><a href=\"#Catalog\" class=\"headerlink\" title=\"Catalog\"></a>Catalog</h3><ul>\n<li>第一日 上古时期 <strong><em>Module?</em></strong> 从设计模式说起</li>\n<li>第二日 石器时代 <strong><em>Script Loader</em></strong> 只有封装性可不够，我们还需要加载</li>\n<li>第三日 蒸汽朋克 <strong><em>Module Loader</em></strong> 模块化架构的工业革命</li>\n<li>第四日 号角吹响 <strong><em>CommonJS</em></strong> 征服世界的第一步是跳出浏览器</li>\n<li>第五日 双塔奇兵 <strong><em>AMD/CMD</em></strong> 浏览器环境模块化方案</li>\n<li>第六日 精灵宝钻 <strong><em>Browserify/Webpack</em></strong> 大势所趋，去掉这层包裹！</li>\n<li>第七日 王者归来 <strong><em>ES6 Module</em></strong> 最后的战役</li>\n</ul>\n<h3 id=\"Thanks\"><a href=\"#Thanks\" class=\"headerlink\" title=\"Thanks\"></a>Thanks</h3><p><a href=\"http://lab.hakim.se/reveal-js\" target=\"_blank\" rel=\"external\">Reveal.js</a></p>\n"},{"layout":"post","title":"We have a problem with promise","subtitle":"Promise","date":"2016-07-04T07:23:00.000Z","author":"Asher","header-img":"home-bg.jpg","header-mask":0.3,"catalog":true,"_content":"\n### *下面四种Promise的区别*\n\n```javascript\n    doSomething().then(() => {\n        return doSomethingElse()\n    })\n\n    doSomething().then(() => {\n        doSomethingElse()\n    })\n\n    doSomething().then(doSomethingElse())\n\n    doSomething().then(doSomethingElse)\n```\n\n## Promise的起源\n\n如果你阅读了 promises 的一些相关文献，你会发现有一个词 [金字塔问题](https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf#.ca5u6o9fl) 经常出现。它描述的是大量的回调函数慢慢向右侧屏幕延伸的一种状态。\n\nPromises 的确解决了这个问题，并且不仅仅是缩进问题。就像在 [Callback Hell的救赎](http://youtu.be/hf1T_AONQJU) 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。相反，我们的整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。\n\n> 原文关于副作用的描述并不能很直观的进行理解，建议参考 [WIKI](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) 。简单来说就是一个函数除了会返回一个值之外，还会修改函数以外的状态如全局变量等等。实际上所有异步调用都可以视为带有副作用的行为。\n\n并且实际上，回调更加恼人的是，他会将我们通常在大部分编程语言中能获得的*堆栈*破坏。编写代码时如果无法获取堆栈就像开车时没有刹车一样: 不到用的时候，你不会知道它有多重要。\n\nPromises 给予我们的就是在我们使用异步时丢失的最重要的语言基石: return, throw 以及堆栈。但是想要 promises 能够提供这些便利给你的前提是你知道如何正确的使用它们。\n\n## 新手错误\n\nPromise对于不同的人有不同的理解和观点，但是这篇文章我特质[正式标准](https://promisesaplus.com/), 在现代浏览器中暴露为window.Promise。虽然并非所有浏览器都有windows.Promise,但是可以寻找一些pollyfill,比如[Lie](https://github.com/calvinmetcalf/lie)、[bluebird](https://github.com/petkaantonov/bluebird)。\n\n### 新手错误 #1： promise版的金字塔问题\n观察大家如何使用 PouchDB 这类大型的 promise 风格的API，我发现大量错误的 promise 使用形式。最常见的错误就是下面这个:\n\n```javascript\n    remotedb.allDocs({\n        include_docs: true,\n        attachments: true\n    }).then(function (result) {\n        var docs = result.rows;\n        docs.forEach(function(element) {\n            localdb.put(element.doc).then(function(response) {\n                alert('Pulled doc with id ' + element.doc._id + ' and added to local db.');\n            }).catch(function (err) {\n                if (err.status == 409) {\n                    localdb.get(element.doc._id).then(function (resp) {\n                        localdb.remove(resp._id, resp._rev).then(function (resp) {\n                                // et cetera...\n                        })\n                    })\n                }\n            })\n        })\n    })\n\n```\n\n是的，实际上你可以像使用回调一样使用 promises，恩，就像用打磨机去削脚趾甲一样，你确实可以这么做。\n\n并且如果你以为这样的错误只限于初学者，那么你会惊讶于我实际上是在黑莓官方开发者博客上看到上面的代码。老的回调风格的习惯难以消灭。(至开发者: 抱歉选了你的例子，但是你的例子将会有积极的教育意义)\n\n正确的风格应该是:\n\n```javascript\n    remotedb.allDocs(...).then(function (resultOfAllDocs) {\n        return localdb.put(...)\n    }).then(function (resultOfPut) {\n        return localdb.get(...)\n    }).then(function (resultOfGet) {\n        return localdb.put(...)\n    }).catch(function (err) {\n        console.log(err)\n    })\n```\n这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用，稍后我们在这块做更多的讨论。\n\n### 新手错误 #2： WTF, 用了 promises 后怎么用 forEach?\n\n这里是大多数人对于 promises 的理解开始出现偏差。一旦当他们要使用他们熟悉的 forEach() 循环 (无论是 for 循环还是 while 循环)，他们完全不知道如何将 promises 与其一起使。因此他们就会写下类似这样的代码。\n\n```javascript\n    // I want to remove() all docs\n    db.allDocs({include_docs: true}).then(function (result) {\n        result.rows.forEach(function (row) {\n            db.remove(row.doc)\n        })\n    }).then(function () {\n        // I naively believe all docs have been removed() now!\n    })\n```\n\n这份代码有什么问题？问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！\n\n这是一个非常隐蔽的 bug，因为如果 PouchDB 删除这些文档足够快，你的 UI 界面上显示的会完成正常，你可能会完全注意不到有什么东西有错误。这个 bug 可能会在一些古怪的竞态问题或一些特定的浏览器中暴露出来，并且到时可能几乎没有可能去定位问题。\n\n简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():\n\n```javascript\n    db.allDocs({include_docs: true}).then(function (result) {\n        return Promise.all(result.rows.map(function (row) {\n            return db.remove(row.doc)\n        }))\n    }).then(function (arrayOfResults) {\n        // All docs have really been removed() now!\n    })\n```\n\n上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。\n\n并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。\n\n### 新手错误 #3： 忘记使用 .catch()\n\n这是另一个常见的错误。单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。\n\n> 类似 Bluebird 之类的 Promise 库会在这种场景抛出 UnhandledRejectionError 警示有未处理的异常，这类情况一旦发现，就会造成脚本异常，在 Node 中更会造成进程 Crash 的问题，因此正确的添加 .catch() 非常重要。 译者注\n\n为了避免这类讨厌的场景，我习惯于像下面的代码一样使用 promise:\n\n```javascript\n    somePromise().then(function () {\n        return anotherPromise();\n    }).then(function () {\n        return yetAnotherPromise();\n    }).catch(console.log.bind(console)); // <-- this is badass\n```\n\n即使你坚信不会出现异常，添加一个 catch() 总归是更加谨慎的。如果你的假设最终被发现是错误的，它会让你的生活更加美好。\n\n### 新手错误 #4：使用 “deferred”\n这是一个我经常可以看到的错误，以至于我甚至不愿意在这里重复它，就像惧怕 Beetlejuice 一样，仅仅是提到它的名字，就会召唤出来更多。\n\n简单的说，promises 拥有一个漫长并且戏剧化的历史，Javascript 社区花费了大量的时间让其走上正轨。在早期，deferred 在 Q，When，RSVP，Bluebird，Lie等等的 “优秀” 类库中被引入， jQuery 与 Angular 在使用 ES6 Promise 规范之前，都是使用这种模式编写代码。\n\n因此如果你在你的代码中使用了这个词 (我不会把这个词重复第三遍！)，你就做错了。下面是说明一下如何避免它。\n\n首先，大部分 promises 类库都会提供一个方式去包装一个第三方的 promises 对象。举例来说，Angular的 $q 模块允许你使用 $q.when 包裹非 $q 的 promises。因此 Angular 用户可以这样使用 PouchDB promises.\n\n```javascript\n    $q.when(db.put(doc)).then(/* ... */); // <-- this is all the code you need\n```\n\n另一种策略是使用[构造函数声明模式](https://blog.domenic.me/the-revealing-constructor-pattern/)，它在用来包裹非 promise API 时非常有用。举例来说，为了包裹一个回调风格的 API 如 Node 的 fs.readFile ，你可以简单的这么做:\n\n```javascript\n    new Promise(function (resolve, reject) {\n        fs.readFile('myfile.txt', function (err, file) {\n            if (err) {\n                return reject(err);\n            }\n            resolve(file);\n        });\n    }).then(/* ... */)\n```\n完工！我们打败了可怕的 def….啊哈，抓到自己了。:)\n\n> 关于为何这是一种反模式更多的内容，请查看 Bluebird 的 [promise anti-patterns](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern) wiki 页\n\n### 新手错误 #5：使用副作用调用而非返回\n\n```javascript\n    somePromise().then(function () {\n        someOtherPromise()\n    }).then(function () {\n        // Gee, I hope someOtherPromise() has resolved!\n        // Spoiler alert: it hasn't.\n    })\n```\n\n好了，现在是时候讨论一下关于 promises 你所需要知道的一切。\n\n认真的说，这是一个一旦你理解了它，就会避免所有我提及的错误的古怪的技巧。你准备好了么？\n\n就如我前面所说，promises 的奇妙在于给予我们以前的 return 与 throw。但是在实践中这到底是怎么一回事呢？\n\n每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, ...) 的语法糖)。当我们在 then() 函数内部时：\n\n```javascript\n    somePromise().then(function () {\n        // I'm inside a then() function!\n    })\n```\n我们可以做什么呢？有三种事情：\n\nreturn 另一个 promise\nreturn 一个同步的值 (或者 undefined)\nthrow 一个同步异常\n就是这样。一旦你理解了这个技巧，你就理解了 promises。因此让我们逐个了解下。\n\n返回另一个 promise\n这是一个在 promise 文档中常见的使用模式，也就是我们在上文中提到的 “composing promises”：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // I got a user account!\n    })\n```\n\n> 注意到我是 `return` 第二个 promise，这个 `return` 非常重要。如果我没有写 `return`，`getUserAccountById()` 就会成为一个副作用，并且下一个函数将会接收到 `undefined` 而非 `userAccount`。\n\n### 返回一个同步值 (或者 undefined)\n\n返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        if (inMemoryCache[user.id]) {\n            return inMemoryCache[user.id]    // returning a synchronous value!\n        }\n        return getUserAccountById(user.id) // returning a promise!\n    }).then(function (userAccount) {\n        // I got a user account!\n    });\n```\n\n是不是很赞？第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。\n\n不幸的是，有一个不便的现实是在 JavaScript 中无返回值函数在技术上是返回 undefined，这就意味着当你本意是返回某些值时，你很容易会不经意间引入副作用。\n\n出于这个原因，我个人养成了在 then() 函数内部 永远返回或抛出 的习惯。我建议你也这样做。\n\n### 抛出同步异常\n\n谈到 throw，这是让 promises 更加赞的一点。比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        if (user.isLoggedOut()) {\n            throw new Error('user logged out!') // throwing a synchronous error!\n        }\n\n        if (inMemoryCache[user.id]) {\n            return inMemoryCache[user.id]       // returning a synchronous value!\n        }\n\n        return getUserAccountById(user.id)   // returning a promise!\n    }).then(function (userAccount) {\n        // I got a user account!\n    }).catch(function (err) {\n        // Boo, I got an error!\n    })\n```\n\n如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。\n\n这种特性非常有用，因此它能够在开发过程中帮助定位代码问题。举例来说，如果在 then() 函数内部中的任何地方，我们执行 JSON.parse()，如果 JSON 格式是错误的，那么它就会抛出一个异常。如果是使用回调风格，这个错误很可能就会被吃掉，但是使用 promises，我们可以轻易的在 catch() 函数中处理它了。\n\n# 进阶错误\n\n好了，现在你已经了解了让 promises 变的超级简单的技巧，现在让我们聊一聊一些特殊场景。\n这些错误之所以被我归类为 “进阶” ，是因为我只见过这些错误发生在对 promises 已经有相当深入了解的开发者身上。但是为了解决文章最开始的谜题，我们必须讨论一下这些错误。\n\n### 进阶错误 #1：不知道 Promise.resolve()\n\n如我上面所列举的，promises 在封装同步与异步代码时非常的有用。然而，如果你发现你经常写出下面的代码：\n\n```javascript\n    new Promise(function (resolve, reject) {\n        resolve(someSynchronousValue)\n    }).then(/* ... */)\n```\n\n你会发现使用 Promise.resolve 会更加简洁：\n\n```javascript\n    Promise.resolve(someSynchronousValue).then(/* ... */);\n```\n\n它在用来捕获同步异常时也极其的好用。由于它实在是好用，因此我已经养成了在我所有 promise 形式的 API 接口中这样使用它：\n\n```javascript\n    function somePromiseAPI() {\n        return Promise.resolve().then(function () {\n            doSomethingThatMayThrow()\n            return 'foo'\n        }).then(/* ... */)\n    }\n```\n\n切记：任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。\n\n类似的，还有 Promise.reject() 你可以用来返回一个立刻返回失败的 promise。\n\n```javascript\n    Promise.reject(new Error('some awful error'));\n```\n\n### 进阶错误 #2：catch() 与 then(null, ...) 并非完全等价\n\n之前我说过 catch() 仅仅是一个语法糖。因此下面两段代码是等价的：\n\n```javascript\n    somePromise().catch(function (err) {\n        // handle error\n    })\n\n    somePromise().then(null, function (err) {\n        // handle error\n    })\n```\n\n然而，这并不意味着下面两段代码是等价的：\n\n```javascript\n    somePromise().then(function () {\n        return someOtherPromise();\n    }).catch(function (err) {\n        // handle error\n    });\n\n    somePromise().then(function () {\n        return someOtherPromise();\n    }, function (err) {\n        // handle error\n    });\n```\n\n如果你好奇为何这两段代码并不等价，可以考虑一下如果第一个函数抛出异常会发生什么：\n\n```javascript\n    somePromise().then(function () {\n        throw new Error('oh noes')\n    }).catch(function (err) {\n        // I caught your error! :)\n    })\n\n    somePromise().then(function () {\n        throw new Error('oh noes')\n    }, function (err) {\n        // I didn't catch your error! :(\n    })\n```\n\n因此，当你使用 then(resolveHandler, rejectHandler) 这种形式时，rejectHandler 并不会捕获由 resolveHandler 引发的异常。\n\n鉴于此，我个人的习惯是不适用 then() 的第二个参数，而是总是使用 catch()。唯一的例外是当我写一些异步的 Mocha 测试用例时，我可能会希望用例的异常可以正确的被抛出：\n\n```javascript\n    it('should throw an error', function () {\n        return doSomethingThatThrows().then(function () {\n            throw new Error('I expected an error!')\n        }, function (err) {\n            should.exist(err)\n        })\n    })\n```\n\n说到这里，[Mocha](http://mochajs.org/) 和 [Chai](http://chaijs.com/) 用来测试 promise 接口时，是一对非常好的组合。 [pouchdb-plugin-seed](https://github.com/pouchdb/plugin-seed) 项目中有一些 [示例](https://github.com/pouchdb/plugin-seed/blob/master/test/test.js) 可以帮助你入门。\n\n### 进阶错误 #3：promises vs promises factories\n\n当我们希望执行一个个的执行一个 promises 序列，即类似 Promise.all() 但是并非并行的执行所有 promises。\n\n你可能天真的写下这样的代码：\n\n```javascript\n    function executeSequentially(promises) {\n        var result = Promise.resolve()\n        promises.forEach(function (promise) {\n            result = result.then(promise)\n        })\n\n        return result\n    }\n```\n\n不幸的是，这份代码不会按照你的期望去执行，你传入 executeSequentially() 的 promises 依然会并行执行。\n\n其根源在于你所希望的，实际上根本不是去执行一个 promises 序列。依照 promises 规范，一旦一个 promise 被创建，它就被执行了。因此你实际上需要的是一个 promise factories 数组。\n\n```javascript\n    function executeSequentially(promiseFactories) {\n        var result = Promise.resolve()\n        promiseFactories.forEach(function (promiseFactory) {\n            result = result.then(promiseFactory)\n        })\n\n        return result\n    }\n```\n\n我知道你在想什么：“这是哪个见鬼的 Java 程序猿，他为啥在说 factories？” 。实际上，一个 promises factory 是十分简单的，它仅仅是一个可以返回 promise 的函数：\n\n```javascript\n    function myPromiseFactory() {\n        return somethingThatCreatesAPromise();\n    }\n```\n\n为何这样就可以了？这是因为一个 promise factory 在被执行之前并不会创建 promise。它就像一个 then 函数一样，而实际上，它们就是完全一样的东西。\n\n如果你查看上面的 executeSequentially() 函数，然后想象 myPromiseFactory 被包裹在 result.then(...) 之中，也许你脑中的小灯泡就会亮起。在此时此刻，对于 promise 你就算是悟道了。\n\n### 进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办\n\n有时候，一个 promise 会依赖于另一个，但是如果我们希望同时获得这两个 promises 的输出。举例来说：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // dangit, I need the \"user\" object too!\n    })\n```\n\n为了成为一个优秀的 Javascript 开发者，并且避免金字塔问题，我们可能会将 user 对象存在一个更高的作用域中的变量里：\n\n```javascript\n    var user\n    getUserByName('nolan')\n    .then(function (result) {\n        user = result\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // okay, I have both the \"user\" and the \"userAccount\"\n    })\n```\n\n这样是没问题的，但是我个人认为这样做有些杂牌。我推荐的策略是抛弃成见，拥抱金字塔：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id).then(function (userAccount) {\n            // okay, I have both the \"user\" and the \"userAccount\"\n        })\n    })\n```\n\n…至少暂时这样是没问题的。一旦缩进开始成为问题，你可以通过 Javascript 开发者从远古时期就开始使用的技巧，将函数抽离到一个命名函数中：\n\n```javascript\n    function onGetUserAndUserAccount(user, userAccount) {\n        return doSomething(user, userAccount)\n    }\n\n    function onGetUser(user) {\n        return getUserAccountById(user.id).then(function (userAccount) {\n            return onGetUserAndUserAccount(user, userAccount)\n        })\n    }\n\n    getUserByName('nolan')\n    .then(onGetUser)\n    .then(function () {\n        // at this point, doSomething() is done, and we are back to indentation 0\n    })\n```\n\n由于你的 promise 代码开始变得更加复杂，你可能发现自己开始将越来越多的函数抽离到命名函数中，我发现这样做，你的代码会越来越漂亮，就像这样：\n\n```javascript\n    putYourRightFootIn()\n    .then(putYourRightFootOut)\n    .then(putYourRightFootIn)\n    .then(shakeItAllAbout)\n```\n\n`这就是 promises 的重点。`\n\n\n### 进阶错误 #5：promises 穿透\n\n最后，这个错误就是我开头说的 promises 谜题所影射的错误。这是一个非常稀有的用例，并且可能完全不会出现在你的代码中，但是的的确确震惊了我。\n\n你认为下面的代码会打印出什么？\n\n```javascript\n    Promise.resolve('foo')\n    .then(Promise.resolve('bar'))\n    .then(function (result) {\n        console.log(result);\n    });\n```\n\n如果你认为它会打印出 bar，那么你就错了。它实际上打印出来的是 foo！\n\n发生这个的原因是如果你像 then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。你可以自己测试一下：\n\n```javascript\n    Promise.resolve('foo')\n    .then(null)\n    .then(function (result) {\n        console.log(result)\n    })\n```\n\n添加任意数量的 then(null)，它依然会打印 foo。\n\n这实际上又回到了我之前说的 promises vs promise factories。简单的说，你可以直接传递一个 promise 到 then() 函数中，但是它并不会按照你期望的去执行。then() 是期望获取一个函数，因此你希望做的最可能是：\n\n```javascript\n    Promise.resolve('foo').then(function () {\n        return Promise.resolve('bar')\n    }).then(function (result) {\n        console.log(result)\n    })\n```\n\n这样他就会如我们所想的打印出 bar。\n\n`因此记住：永远都是往 then() 中传递函数！`\n\n\n### 期待 async/await\n在 “[Taming the asynchronous beast with ES7](https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html)” 中提到的重点，在这篇文章中我探究了 ES7 的 async/await 关键字，以及它们是如何将 promises 更深度的结合入语言。不再会要求我们去编写伪同步的代码（以及一个假的 catch() 函数，虽然像，但是并非是 catch），ES7 将会允许我们使用真正的 try/catch/return 关键字，就像我们在 CS 101 上学的一样。\n\n这对于 Javascript 语言来说是一个大福音。因为即使到最后，只要我们的工具不告诉我们做错了，这些 promise 反模式依然会一直出现。\n\n从 JavaScript 的历史来看，我认为公正的评价来说 JSLint 与 JSHint 对社区的贡献是高于 JavaScript: The Good Parts 的，虽然他们包含的信息实际上是相同的。但是它们的区别在于 被告知你在你代码中犯的错误 与你去阅读一本书籍，去理解其他人犯的错误。\n\nES7 的 async/await 的美妙在于，你的错误会被作为语法或者编译器错误提示出来，而不是运行时的 bug。不过就目前而言，了解 promise 可以做什么以及如何在 ES5 与 ES6 中正确的使用它们依然是有必要的。\n\n因此当我意识到，就像 JavaScript: The Good Parts 一样，这篇博文可能只会有非常有限的影响的时候，我希望当你发现其他人在犯同样的错误的时候，你可以将这篇博文提供给他们。因为现在依然有很多同学需要承认: “I have a problem with promises!”\n\n```javascript\n\n// Promise.all is good for executing many promises at once\nPromise.all([\n  promise1,\n  promise2\n]);\n\n// Promise.resolve is good for wrapping synchronous code\nPromise.resolve().then(function () {\n  if (somethingIsNotRight()) {\n    throw new Error(\"I will be rejected asynchronously!\");\n  } else {\n    return \"This string will be resolved asynchronously!\";\n  }\n});\n\n// execute some promises one after the other.\n// this takes an array of promise factories, i.e.\n// an array of functions that RETURN a promise\n// (not an array of promises themselves; those would execute immediately)\nfunction sequentialize(promiseFactories) {\n  var chain = Promise.resolve();\n  promiseFactories.forEach(function (promiseFactory) {\n    chain = chain.then(promiseFactory);\n  });\n  return chain;\n}\n\n// Promise.race is good for setting a timeout:\nPromise.race([\n  new Promise(function (resolve, reject) {\n    setTimeout(reject, 10000); // timeout after 10 secs\n  }),\n  doSomethingThatMayTakeAwhile()\n]);\n\n// Promise finally util similar to Q.finally\n// e.g. promise.then(...).catch().then(...).finally(...)\nfunction finally (promise, cb) {\n  return promise.then(function (res) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        return res;\n      });\n    }\n    return res;\n  }, function (reason) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        throw reason;\n      });\n    }\n    throw reason;\n  });\n};\n\n```\n","source":"_posts/2017-03-06-we-have-a-problem-with-promise.markdown","raw":"---\nlayout:     post\ntitle:      \"We have a problem with promise\"\nsubtitle:   \"Promise\"\ndate:       2016-07-04 15:23\nauthor:     \"Asher\"\nheader-img: \"home-bg.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - Promise\n---\n\n### *下面四种Promise的区别*\n\n```javascript\n    doSomething().then(() => {\n        return doSomethingElse()\n    })\n\n    doSomething().then(() => {\n        doSomethingElse()\n    })\n\n    doSomething().then(doSomethingElse())\n\n    doSomething().then(doSomethingElse)\n```\n\n## Promise的起源\n\n如果你阅读了 promises 的一些相关文献，你会发现有一个词 [金字塔问题](https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf#.ca5u6o9fl) 经常出现。它描述的是大量的回调函数慢慢向右侧屏幕延伸的一种状态。\n\nPromises 的确解决了这个问题，并且不仅仅是缩进问题。就像在 [Callback Hell的救赎](http://youtu.be/hf1T_AONQJU) 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。相反，我们的整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。\n\n> 原文关于副作用的描述并不能很直观的进行理解，建议参考 [WIKI](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) 。简单来说就是一个函数除了会返回一个值之外，还会修改函数以外的状态如全局变量等等。实际上所有异步调用都可以视为带有副作用的行为。\n\n并且实际上，回调更加恼人的是，他会将我们通常在大部分编程语言中能获得的*堆栈*破坏。编写代码时如果无法获取堆栈就像开车时没有刹车一样: 不到用的时候，你不会知道它有多重要。\n\nPromises 给予我们的就是在我们使用异步时丢失的最重要的语言基石: return, throw 以及堆栈。但是想要 promises 能够提供这些便利给你的前提是你知道如何正确的使用它们。\n\n## 新手错误\n\nPromise对于不同的人有不同的理解和观点，但是这篇文章我特质[正式标准](https://promisesaplus.com/), 在现代浏览器中暴露为window.Promise。虽然并非所有浏览器都有windows.Promise,但是可以寻找一些pollyfill,比如[Lie](https://github.com/calvinmetcalf/lie)、[bluebird](https://github.com/petkaantonov/bluebird)。\n\n### 新手错误 #1： promise版的金字塔问题\n观察大家如何使用 PouchDB 这类大型的 promise 风格的API，我发现大量错误的 promise 使用形式。最常见的错误就是下面这个:\n\n```javascript\n    remotedb.allDocs({\n        include_docs: true,\n        attachments: true\n    }).then(function (result) {\n        var docs = result.rows;\n        docs.forEach(function(element) {\n            localdb.put(element.doc).then(function(response) {\n                alert('Pulled doc with id ' + element.doc._id + ' and added to local db.');\n            }).catch(function (err) {\n                if (err.status == 409) {\n                    localdb.get(element.doc._id).then(function (resp) {\n                        localdb.remove(resp._id, resp._rev).then(function (resp) {\n                                // et cetera...\n                        })\n                    })\n                }\n            })\n        })\n    })\n\n```\n\n是的，实际上你可以像使用回调一样使用 promises，恩，就像用打磨机去削脚趾甲一样，你确实可以这么做。\n\n并且如果你以为这样的错误只限于初学者，那么你会惊讶于我实际上是在黑莓官方开发者博客上看到上面的代码。老的回调风格的习惯难以消灭。(至开发者: 抱歉选了你的例子，但是你的例子将会有积极的教育意义)\n\n正确的风格应该是:\n\n```javascript\n    remotedb.allDocs(...).then(function (resultOfAllDocs) {\n        return localdb.put(...)\n    }).then(function (resultOfPut) {\n        return localdb.get(...)\n    }).then(function (resultOfGet) {\n        return localdb.put(...)\n    }).catch(function (err) {\n        console.log(err)\n    })\n```\n这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用，稍后我们在这块做更多的讨论。\n\n### 新手错误 #2： WTF, 用了 promises 后怎么用 forEach?\n\n这里是大多数人对于 promises 的理解开始出现偏差。一旦当他们要使用他们熟悉的 forEach() 循环 (无论是 for 循环还是 while 循环)，他们完全不知道如何将 promises 与其一起使。因此他们就会写下类似这样的代码。\n\n```javascript\n    // I want to remove() all docs\n    db.allDocs({include_docs: true}).then(function (result) {\n        result.rows.forEach(function (row) {\n            db.remove(row.doc)\n        })\n    }).then(function () {\n        // I naively believe all docs have been removed() now!\n    })\n```\n\n这份代码有什么问题？问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！\n\n这是一个非常隐蔽的 bug，因为如果 PouchDB 删除这些文档足够快，你的 UI 界面上显示的会完成正常，你可能会完全注意不到有什么东西有错误。这个 bug 可能会在一些古怪的竞态问题或一些特定的浏览器中暴露出来，并且到时可能几乎没有可能去定位问题。\n\n简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():\n\n```javascript\n    db.allDocs({include_docs: true}).then(function (result) {\n        return Promise.all(result.rows.map(function (row) {\n            return db.remove(row.doc)\n        }))\n    }).then(function (arrayOfResults) {\n        // All docs have really been removed() now!\n    })\n```\n\n上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。\n\n并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。\n\n### 新手错误 #3： 忘记使用 .catch()\n\n这是另一个常见的错误。单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。\n\n> 类似 Bluebird 之类的 Promise 库会在这种场景抛出 UnhandledRejectionError 警示有未处理的异常，这类情况一旦发现，就会造成脚本异常，在 Node 中更会造成进程 Crash 的问题，因此正确的添加 .catch() 非常重要。 译者注\n\n为了避免这类讨厌的场景，我习惯于像下面的代码一样使用 promise:\n\n```javascript\n    somePromise().then(function () {\n        return anotherPromise();\n    }).then(function () {\n        return yetAnotherPromise();\n    }).catch(console.log.bind(console)); // <-- this is badass\n```\n\n即使你坚信不会出现异常，添加一个 catch() 总归是更加谨慎的。如果你的假设最终被发现是错误的，它会让你的生活更加美好。\n\n### 新手错误 #4：使用 “deferred”\n这是一个我经常可以看到的错误，以至于我甚至不愿意在这里重复它，就像惧怕 Beetlejuice 一样，仅仅是提到它的名字，就会召唤出来更多。\n\n简单的说，promises 拥有一个漫长并且戏剧化的历史，Javascript 社区花费了大量的时间让其走上正轨。在早期，deferred 在 Q，When，RSVP，Bluebird，Lie等等的 “优秀” 类库中被引入， jQuery 与 Angular 在使用 ES6 Promise 规范之前，都是使用这种模式编写代码。\n\n因此如果你在你的代码中使用了这个词 (我不会把这个词重复第三遍！)，你就做错了。下面是说明一下如何避免它。\n\n首先，大部分 promises 类库都会提供一个方式去包装一个第三方的 promises 对象。举例来说，Angular的 $q 模块允许你使用 $q.when 包裹非 $q 的 promises。因此 Angular 用户可以这样使用 PouchDB promises.\n\n```javascript\n    $q.when(db.put(doc)).then(/* ... */); // <-- this is all the code you need\n```\n\n另一种策略是使用[构造函数声明模式](https://blog.domenic.me/the-revealing-constructor-pattern/)，它在用来包裹非 promise API 时非常有用。举例来说，为了包裹一个回调风格的 API 如 Node 的 fs.readFile ，你可以简单的这么做:\n\n```javascript\n    new Promise(function (resolve, reject) {\n        fs.readFile('myfile.txt', function (err, file) {\n            if (err) {\n                return reject(err);\n            }\n            resolve(file);\n        });\n    }).then(/* ... */)\n```\n完工！我们打败了可怕的 def….啊哈，抓到自己了。:)\n\n> 关于为何这是一种反模式更多的内容，请查看 Bluebird 的 [promise anti-patterns](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern) wiki 页\n\n### 新手错误 #5：使用副作用调用而非返回\n\n```javascript\n    somePromise().then(function () {\n        someOtherPromise()\n    }).then(function () {\n        // Gee, I hope someOtherPromise() has resolved!\n        // Spoiler alert: it hasn't.\n    })\n```\n\n好了，现在是时候讨论一下关于 promises 你所需要知道的一切。\n\n认真的说，这是一个一旦你理解了它，就会避免所有我提及的错误的古怪的技巧。你准备好了么？\n\n就如我前面所说，promises 的奇妙在于给予我们以前的 return 与 throw。但是在实践中这到底是怎么一回事呢？\n\n每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, ...) 的语法糖)。当我们在 then() 函数内部时：\n\n```javascript\n    somePromise().then(function () {\n        // I'm inside a then() function!\n    })\n```\n我们可以做什么呢？有三种事情：\n\nreturn 另一个 promise\nreturn 一个同步的值 (或者 undefined)\nthrow 一个同步异常\n就是这样。一旦你理解了这个技巧，你就理解了 promises。因此让我们逐个了解下。\n\n返回另一个 promise\n这是一个在 promise 文档中常见的使用模式，也就是我们在上文中提到的 “composing promises”：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // I got a user account!\n    })\n```\n\n> 注意到我是 `return` 第二个 promise，这个 `return` 非常重要。如果我没有写 `return`，`getUserAccountById()` 就会成为一个副作用，并且下一个函数将会接收到 `undefined` 而非 `userAccount`。\n\n### 返回一个同步值 (或者 undefined)\n\n返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        if (inMemoryCache[user.id]) {\n            return inMemoryCache[user.id]    // returning a synchronous value!\n        }\n        return getUserAccountById(user.id) // returning a promise!\n    }).then(function (userAccount) {\n        // I got a user account!\n    });\n```\n\n是不是很赞？第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。\n\n不幸的是，有一个不便的现实是在 JavaScript 中无返回值函数在技术上是返回 undefined，这就意味着当你本意是返回某些值时，你很容易会不经意间引入副作用。\n\n出于这个原因，我个人养成了在 then() 函数内部 永远返回或抛出 的习惯。我建议你也这样做。\n\n### 抛出同步异常\n\n谈到 throw，这是让 promises 更加赞的一点。比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        if (user.isLoggedOut()) {\n            throw new Error('user logged out!') // throwing a synchronous error!\n        }\n\n        if (inMemoryCache[user.id]) {\n            return inMemoryCache[user.id]       // returning a synchronous value!\n        }\n\n        return getUserAccountById(user.id)   // returning a promise!\n    }).then(function (userAccount) {\n        // I got a user account!\n    }).catch(function (err) {\n        // Boo, I got an error!\n    })\n```\n\n如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。\n\n这种特性非常有用，因此它能够在开发过程中帮助定位代码问题。举例来说，如果在 then() 函数内部中的任何地方，我们执行 JSON.parse()，如果 JSON 格式是错误的，那么它就会抛出一个异常。如果是使用回调风格，这个错误很可能就会被吃掉，但是使用 promises，我们可以轻易的在 catch() 函数中处理它了。\n\n# 进阶错误\n\n好了，现在你已经了解了让 promises 变的超级简单的技巧，现在让我们聊一聊一些特殊场景。\n这些错误之所以被我归类为 “进阶” ，是因为我只见过这些错误发生在对 promises 已经有相当深入了解的开发者身上。但是为了解决文章最开始的谜题，我们必须讨论一下这些错误。\n\n### 进阶错误 #1：不知道 Promise.resolve()\n\n如我上面所列举的，promises 在封装同步与异步代码时非常的有用。然而，如果你发现你经常写出下面的代码：\n\n```javascript\n    new Promise(function (resolve, reject) {\n        resolve(someSynchronousValue)\n    }).then(/* ... */)\n```\n\n你会发现使用 Promise.resolve 会更加简洁：\n\n```javascript\n    Promise.resolve(someSynchronousValue).then(/* ... */);\n```\n\n它在用来捕获同步异常时也极其的好用。由于它实在是好用，因此我已经养成了在我所有 promise 形式的 API 接口中这样使用它：\n\n```javascript\n    function somePromiseAPI() {\n        return Promise.resolve().then(function () {\n            doSomethingThatMayThrow()\n            return 'foo'\n        }).then(/* ... */)\n    }\n```\n\n切记：任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。\n\n类似的，还有 Promise.reject() 你可以用来返回一个立刻返回失败的 promise。\n\n```javascript\n    Promise.reject(new Error('some awful error'));\n```\n\n### 进阶错误 #2：catch() 与 then(null, ...) 并非完全等价\n\n之前我说过 catch() 仅仅是一个语法糖。因此下面两段代码是等价的：\n\n```javascript\n    somePromise().catch(function (err) {\n        // handle error\n    })\n\n    somePromise().then(null, function (err) {\n        // handle error\n    })\n```\n\n然而，这并不意味着下面两段代码是等价的：\n\n```javascript\n    somePromise().then(function () {\n        return someOtherPromise();\n    }).catch(function (err) {\n        // handle error\n    });\n\n    somePromise().then(function () {\n        return someOtherPromise();\n    }, function (err) {\n        // handle error\n    });\n```\n\n如果你好奇为何这两段代码并不等价，可以考虑一下如果第一个函数抛出异常会发生什么：\n\n```javascript\n    somePromise().then(function () {\n        throw new Error('oh noes')\n    }).catch(function (err) {\n        // I caught your error! :)\n    })\n\n    somePromise().then(function () {\n        throw new Error('oh noes')\n    }, function (err) {\n        // I didn't catch your error! :(\n    })\n```\n\n因此，当你使用 then(resolveHandler, rejectHandler) 这种形式时，rejectHandler 并不会捕获由 resolveHandler 引发的异常。\n\n鉴于此，我个人的习惯是不适用 then() 的第二个参数，而是总是使用 catch()。唯一的例外是当我写一些异步的 Mocha 测试用例时，我可能会希望用例的异常可以正确的被抛出：\n\n```javascript\n    it('should throw an error', function () {\n        return doSomethingThatThrows().then(function () {\n            throw new Error('I expected an error!')\n        }, function (err) {\n            should.exist(err)\n        })\n    })\n```\n\n说到这里，[Mocha](http://mochajs.org/) 和 [Chai](http://chaijs.com/) 用来测试 promise 接口时，是一对非常好的组合。 [pouchdb-plugin-seed](https://github.com/pouchdb/plugin-seed) 项目中有一些 [示例](https://github.com/pouchdb/plugin-seed/blob/master/test/test.js) 可以帮助你入门。\n\n### 进阶错误 #3：promises vs promises factories\n\n当我们希望执行一个个的执行一个 promises 序列，即类似 Promise.all() 但是并非并行的执行所有 promises。\n\n你可能天真的写下这样的代码：\n\n```javascript\n    function executeSequentially(promises) {\n        var result = Promise.resolve()\n        promises.forEach(function (promise) {\n            result = result.then(promise)\n        })\n\n        return result\n    }\n```\n\n不幸的是，这份代码不会按照你的期望去执行，你传入 executeSequentially() 的 promises 依然会并行执行。\n\n其根源在于你所希望的，实际上根本不是去执行一个 promises 序列。依照 promises 规范，一旦一个 promise 被创建，它就被执行了。因此你实际上需要的是一个 promise factories 数组。\n\n```javascript\n    function executeSequentially(promiseFactories) {\n        var result = Promise.resolve()\n        promiseFactories.forEach(function (promiseFactory) {\n            result = result.then(promiseFactory)\n        })\n\n        return result\n    }\n```\n\n我知道你在想什么：“这是哪个见鬼的 Java 程序猿，他为啥在说 factories？” 。实际上，一个 promises factory 是十分简单的，它仅仅是一个可以返回 promise 的函数：\n\n```javascript\n    function myPromiseFactory() {\n        return somethingThatCreatesAPromise();\n    }\n```\n\n为何这样就可以了？这是因为一个 promise factory 在被执行之前并不会创建 promise。它就像一个 then 函数一样，而实际上，它们就是完全一样的东西。\n\n如果你查看上面的 executeSequentially() 函数，然后想象 myPromiseFactory 被包裹在 result.then(...) 之中，也许你脑中的小灯泡就会亮起。在此时此刻，对于 promise 你就算是悟道了。\n\n### 进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办\n\n有时候，一个 promise 会依赖于另一个，但是如果我们希望同时获得这两个 promises 的输出。举例来说：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // dangit, I need the \"user\" object too!\n    })\n```\n\n为了成为一个优秀的 Javascript 开发者，并且避免金字塔问题，我们可能会将 user 对象存在一个更高的作用域中的变量里：\n\n```javascript\n    var user\n    getUserByName('nolan')\n    .then(function (result) {\n        user = result\n        return getUserAccountById(user.id)\n    }).then(function (userAccount) {\n        // okay, I have both the \"user\" and the \"userAccount\"\n    })\n```\n\n这样是没问题的，但是我个人认为这样做有些杂牌。我推荐的策略是抛弃成见，拥抱金字塔：\n\n```javascript\n    getUserByName('nolan').then(function (user) {\n        return getUserAccountById(user.id).then(function (userAccount) {\n            // okay, I have both the \"user\" and the \"userAccount\"\n        })\n    })\n```\n\n…至少暂时这样是没问题的。一旦缩进开始成为问题，你可以通过 Javascript 开发者从远古时期就开始使用的技巧，将函数抽离到一个命名函数中：\n\n```javascript\n    function onGetUserAndUserAccount(user, userAccount) {\n        return doSomething(user, userAccount)\n    }\n\n    function onGetUser(user) {\n        return getUserAccountById(user.id).then(function (userAccount) {\n            return onGetUserAndUserAccount(user, userAccount)\n        })\n    }\n\n    getUserByName('nolan')\n    .then(onGetUser)\n    .then(function () {\n        // at this point, doSomething() is done, and we are back to indentation 0\n    })\n```\n\n由于你的 promise 代码开始变得更加复杂，你可能发现自己开始将越来越多的函数抽离到命名函数中，我发现这样做，你的代码会越来越漂亮，就像这样：\n\n```javascript\n    putYourRightFootIn()\n    .then(putYourRightFootOut)\n    .then(putYourRightFootIn)\n    .then(shakeItAllAbout)\n```\n\n`这就是 promises 的重点。`\n\n\n### 进阶错误 #5：promises 穿透\n\n最后，这个错误就是我开头说的 promises 谜题所影射的错误。这是一个非常稀有的用例，并且可能完全不会出现在你的代码中，但是的的确确震惊了我。\n\n你认为下面的代码会打印出什么？\n\n```javascript\n    Promise.resolve('foo')\n    .then(Promise.resolve('bar'))\n    .then(function (result) {\n        console.log(result);\n    });\n```\n\n如果你认为它会打印出 bar，那么你就错了。它实际上打印出来的是 foo！\n\n发生这个的原因是如果你像 then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。你可以自己测试一下：\n\n```javascript\n    Promise.resolve('foo')\n    .then(null)\n    .then(function (result) {\n        console.log(result)\n    })\n```\n\n添加任意数量的 then(null)，它依然会打印 foo。\n\n这实际上又回到了我之前说的 promises vs promise factories。简单的说，你可以直接传递一个 promise 到 then() 函数中，但是它并不会按照你期望的去执行。then() 是期望获取一个函数，因此你希望做的最可能是：\n\n```javascript\n    Promise.resolve('foo').then(function () {\n        return Promise.resolve('bar')\n    }).then(function (result) {\n        console.log(result)\n    })\n```\n\n这样他就会如我们所想的打印出 bar。\n\n`因此记住：永远都是往 then() 中传递函数！`\n\n\n### 期待 async/await\n在 “[Taming the asynchronous beast with ES7](https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html)” 中提到的重点，在这篇文章中我探究了 ES7 的 async/await 关键字，以及它们是如何将 promises 更深度的结合入语言。不再会要求我们去编写伪同步的代码（以及一个假的 catch() 函数，虽然像，但是并非是 catch），ES7 将会允许我们使用真正的 try/catch/return 关键字，就像我们在 CS 101 上学的一样。\n\n这对于 Javascript 语言来说是一个大福音。因为即使到最后，只要我们的工具不告诉我们做错了，这些 promise 反模式依然会一直出现。\n\n从 JavaScript 的历史来看，我认为公正的评价来说 JSLint 与 JSHint 对社区的贡献是高于 JavaScript: The Good Parts 的，虽然他们包含的信息实际上是相同的。但是它们的区别在于 被告知你在你代码中犯的错误 与你去阅读一本书籍，去理解其他人犯的错误。\n\nES7 的 async/await 的美妙在于，你的错误会被作为语法或者编译器错误提示出来，而不是运行时的 bug。不过就目前而言，了解 promise 可以做什么以及如何在 ES5 与 ES6 中正确的使用它们依然是有必要的。\n\n因此当我意识到，就像 JavaScript: The Good Parts 一样，这篇博文可能只会有非常有限的影响的时候，我希望当你发现其他人在犯同样的错误的时候，你可以将这篇博文提供给他们。因为现在依然有很多同学需要承认: “I have a problem with promises!”\n\n```javascript\n\n// Promise.all is good for executing many promises at once\nPromise.all([\n  promise1,\n  promise2\n]);\n\n// Promise.resolve is good for wrapping synchronous code\nPromise.resolve().then(function () {\n  if (somethingIsNotRight()) {\n    throw new Error(\"I will be rejected asynchronously!\");\n  } else {\n    return \"This string will be resolved asynchronously!\";\n  }\n});\n\n// execute some promises one after the other.\n// this takes an array of promise factories, i.e.\n// an array of functions that RETURN a promise\n// (not an array of promises themselves; those would execute immediately)\nfunction sequentialize(promiseFactories) {\n  var chain = Promise.resolve();\n  promiseFactories.forEach(function (promiseFactory) {\n    chain = chain.then(promiseFactory);\n  });\n  return chain;\n}\n\n// Promise.race is good for setting a timeout:\nPromise.race([\n  new Promise(function (resolve, reject) {\n    setTimeout(reject, 10000); // timeout after 10 secs\n  }),\n  doSomethingThatMayTakeAwhile()\n]);\n\n// Promise finally util similar to Q.finally\n// e.g. promise.then(...).catch().then(...).finally(...)\nfunction finally (promise, cb) {\n  return promise.then(function (res) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        return res;\n      });\n    }\n    return res;\n  }, function (reason) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        throw reason;\n      });\n    }\n    throw reason;\n  });\n};\n\n```\n","slug":"2017-03-06-we-have-a-problem-with-promise","published":1,"updated":"2017-05-27T01:50:29.000Z","comments":1,"photos":[],"link":"","_id":"cj36yugam0009wkt73vk2pe25","content":"<h3 id=\"下面四种Promise的区别\"><a href=\"#下面四种Promise的区别\" class=\"headerlink\" title=\"下面四种Promise的区别\"></a><em>下面四种Promise的区别</em></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">doSomething().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomethingElse()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">doSomething().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    doSomethingElse()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">doSomething().then(doSomethingElse())</div><div class=\"line\"></div><div class=\"line\">doSomething().then(doSomethingElse)</div></pre></td></tr></table></figure>\n<h2 id=\"Promise的起源\"><a href=\"#Promise的起源\" class=\"headerlink\" title=\"Promise的起源\"></a>Promise的起源</h2><p>如果你阅读了 promises 的一些相关文献，你会发现有一个词 <a href=\"https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf#.ca5u6o9fl\" target=\"_blank\" rel=\"external\">金字塔问题</a> 经常出现。它描述的是大量的回调函数慢慢向右侧屏幕延伸的一种状态。</p>\n<p>Promises 的确解决了这个问题，并且不仅仅是缩进问题。就像在 <a href=\"http://youtu.be/hf1T_AONQJU\" target=\"_blank\" rel=\"external\">Callback Hell的救赎</a> 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。相反，我们的整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。</p>\n<blockquote>\n<p>原文关于副作用的描述并不能很直观的进行理解，建议参考 <a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science\" target=\"_blank\" rel=\"external\">WIKI</a>) 。简单来说就是一个函数除了会返回一个值之外，还会修改函数以外的状态如全局变量等等。实际上所有异步调用都可以视为带有副作用的行为。</p>\n</blockquote>\n<p>并且实际上，回调更加恼人的是，他会将我们通常在大部分编程语言中能获得的<em>堆栈</em>破坏。编写代码时如果无法获取堆栈就像开车时没有刹车一样: 不到用的时候，你不会知道它有多重要。</p>\n<p>Promises 给予我们的就是在我们使用异步时丢失的最重要的语言基石: return, throw 以及堆栈。但是想要 promises 能够提供这些便利给你的前提是你知道如何正确的使用它们。</p>\n<h2 id=\"新手错误\"><a href=\"#新手错误\" class=\"headerlink\" title=\"新手错误\"></a>新手错误</h2><p>Promise对于不同的人有不同的理解和观点，但是这篇文章我特质<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"external\">正式标准</a>, 在现代浏览器中暴露为window.Promise。虽然并非所有浏览器都有windows.Promise,但是可以寻找一些pollyfill,比如<a href=\"https://github.com/calvinmetcalf/lie\" target=\"_blank\" rel=\"external\">Lie</a>、<a href=\"https://github.com/petkaantonov/bluebird\" target=\"_blank\" rel=\"external\">bluebird</a>。</p>\n<h3 id=\"新手错误-1：-promise版的金字塔问题\"><a href=\"#新手错误-1：-promise版的金字塔问题\" class=\"headerlink\" title=\"新手错误 #1： promise版的金字塔问题\"></a>新手错误 #1： promise版的金字塔问题</h3><p>观察大家如何使用 PouchDB 这类大型的 promise 风格的API，我发现大量错误的 promise 使用形式。最常见的错误就是下面这个:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">remotedb.allDocs(&#123;</div><div class=\"line\">    <span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">attachments</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> docs = result.rows;</div><div class=\"line\">    docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">        localdb.put(element.doc).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"string\">'Pulled doc with id '</span> + element.doc._id + <span class=\"string\">' and added to local db.'</span>);</div><div class=\"line\">        &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err.status == <span class=\"number\">409</span>) &#123;</div><div class=\"line\">                localdb.get(element.doc._id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resp</span>) </span>&#123;</div><div class=\"line\">                    localdb.remove(resp._id, resp._rev).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resp</span>) </span>&#123;</div><div class=\"line\">                            <span class=\"comment\">// et cetera...</span></div><div class=\"line\">                    &#125;)</div><div class=\"line\">                &#125;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>是的，实际上你可以像使用回调一样使用 promises，恩，就像用打磨机去削脚趾甲一样，你确实可以这么做。</p>\n<p>并且如果你以为这样的错误只限于初学者，那么你会惊讶于我实际上是在黑莓官方开发者博客上看到上面的代码。老的回调风格的习惯难以消灭。(至开发者: 抱歉选了你的例子，但是你的例子将会有积极的教育意义)</p>\n<p>正确的风格应该是:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">remotedb.allDocs(...).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfAllDocs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.put(...)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfPut</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.get(...)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfGet</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.put(...)</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(err)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用，稍后我们在这块做更多的讨论。</p>\n<h3 id=\"新手错误-2：-WTF-用了-promises-后怎么用-forEach\"><a href=\"#新手错误-2：-WTF-用了-promises-后怎么用-forEach\" class=\"headerlink\" title=\"新手错误 #2： WTF, 用了 promises 后怎么用 forEach?\"></a>新手错误 #2： WTF, 用了 promises 后怎么用 forEach?</h3><p>这里是大多数人对于 promises 的理解开始出现偏差。一旦当他们要使用他们熟悉的 forEach() 循环 (无论是 for 循环还是 while 循环)，他们完全不知道如何将 promises 与其一起使。因此他们就会写下类似这样的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// I want to remove() all docs</span></div><div class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    result.rows.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">row</span>) </span>&#123;</div><div class=\"line\">        db.remove(row.doc)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I naively believe all docs have been removed() now!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这份代码有什么问题？问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！</p>\n<p>这是一个非常隐蔽的 bug，因为如果 PouchDB 删除这些文档足够快，你的 UI 界面上显示的会完成正常，你可能会完全注意不到有什么东西有错误。这个 bug 可能会在一些古怪的竞态问题或一些特定的浏览器中暴露出来，并且到时可能几乎没有可能去定位问题。</p>\n<p>简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(result.rows.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">row</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> db.remove(row.doc)</div><div class=\"line\">    &#125;))</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arrayOfResults</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// All docs have really been removed() now!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。</p>\n<p>并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。</p>\n<h3 id=\"新手错误-3：-忘记使用-catch\"><a href=\"#新手错误-3：-忘记使用-catch\" class=\"headerlink\" title=\"新手错误 #3： 忘记使用 .catch()\"></a>新手错误 #3： 忘记使用 .catch()</h3><p>这是另一个常见的错误。单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。</p>\n<blockquote>\n<p>类似 Bluebird 之类的 Promise 库会在这种场景抛出 UnhandledRejectionError 警示有未处理的异常，这类情况一旦发现，就会造成脚本异常，在 Node 中更会造成进程 Crash 的问题，因此正确的添加 .catch() 非常重要。 译者注</p>\n</blockquote>\n<p>为了避免这类讨厌的场景，我习惯于像下面的代码一样使用 promise:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> anotherPromise();</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> yetAnotherPromise();</div><div class=\"line\">&#125;).catch(<span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>)); <span class=\"comment\">// &lt;-- this is badass</span></div></pre></td></tr></table></figure>\n<p>即使你坚信不会出现异常，添加一个 catch() 总归是更加谨慎的。如果你的假设最终被发现是错误的，它会让你的生活更加美好。</p>\n<h3 id=\"新手错误-4：使用-“deferred”\"><a href=\"#新手错误-4：使用-“deferred”\" class=\"headerlink\" title=\"新手错误 #4：使用 “deferred”\"></a>新手错误 #4：使用 “deferred”</h3><p>这是一个我经常可以看到的错误，以至于我甚至不愿意在这里重复它，就像惧怕 Beetlejuice 一样，仅仅是提到它的名字，就会召唤出来更多。</p>\n<p>简单的说，promises 拥有一个漫长并且戏剧化的历史，Javascript 社区花费了大量的时间让其走上正轨。在早期，deferred 在 Q，When，RSVP，Bluebird，Lie等等的 “优秀” 类库中被引入， jQuery 与 Angular 在使用 ES6 Promise 规范之前，都是使用这种模式编写代码。</p>\n<p>因此如果你在你的代码中使用了这个词 (我不会把这个词重复第三遍！)，你就做错了。下面是说明一下如何避免它。</p>\n<p>首先，大部分 promises 类库都会提供一个方式去包装一个第三方的 promises 对象。举例来说，Angular的 $q 模块允许你使用 $q.when 包裹非 $q 的 promises。因此 Angular 用户可以这样使用 PouchDB promises.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$q.when(db.put(doc)).then(<span class=\"comment\">/* ... */</span>); <span class=\"comment\">// &lt;-- this is all the code you need</span></div></pre></td></tr></table></figure>\n<p>另一种策略是使用<a href=\"https://blog.domenic.me/the-revealing-constructor-pattern/\" target=\"_blank\" rel=\"external\">构造函数声明模式</a>，它在用来包裹非 promise API 时非常有用。举例来说，为了包裹一个回调风格的 API 如 Node 的 fs.readFile ，你可以简单的这么做:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    fs.readFile(<span class=\"string\">'myfile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, file</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> reject(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        resolve(file);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</div></pre></td></tr></table></figure>\n<p>完工！我们打败了可怕的 def….啊哈，抓到自己了。:)</p>\n<blockquote>\n<p>关于为何这是一种反模式更多的内容，请查看 Bluebird 的 <a href=\"https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern\" target=\"_blank\" rel=\"external\">promise anti-patterns</a> wiki 页</p>\n</blockquote>\n<h3 id=\"新手错误-5：使用副作用调用而非返回\"><a href=\"#新手错误-5：使用副作用调用而非返回\" class=\"headerlink\" title=\"新手错误 #5：使用副作用调用而非返回\"></a>新手错误 #5：使用副作用调用而非返回</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    someOtherPromise()</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Gee, I hope someOtherPromise() has resolved!</span></div><div class=\"line\">    <span class=\"comment\">// Spoiler alert: it hasn't.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>好了，现在是时候讨论一下关于 promises 你所需要知道的一切。</p>\n<p>认真的说，这是一个一旦你理解了它，就会避免所有我提及的错误的古怪的技巧。你准备好了么？</p>\n<p>就如我前面所说，promises 的奇妙在于给予我们以前的 return 与 throw。但是在实践中这到底是怎么一回事呢？</p>\n<p>每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, …) 的语法糖)。当我们在 then() 函数内部时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I'm inside a then() function!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们可以做什么呢？有三种事情：</p>\n<p>return 另一个 promise<br>return 一个同步的值 (或者 undefined)<br>throw 一个同步异常<br>就是这样。一旦你理解了这个技巧，你就理解了 promises。因此让我们逐个了解下。</p>\n<p>返回另一个 promise<br>这是一个在 promise 文档中常见的使用模式，也就是我们在上文中提到的 “composing promises”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意到我是 <code>return</code> 第二个 promise，这个 <code>return</code> 非常重要。如果我没有写 <code>return</code>，<code>getUserAccountById()</code> 就会成为一个副作用，并且下一个函数将会接收到 <code>undefined</code> 而非 <code>userAccount</code>。</p>\n</blockquote>\n<h3 id=\"返回一个同步值-或者-undefined\"><a href=\"#返回一个同步值-或者-undefined\" class=\"headerlink\" title=\"返回一个同步值 (或者 undefined)\"></a>返回一个同步值 (或者 undefined)</h3><p>返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> inMemoryCache[user.id]    <span class=\"comment\">// returning a synchronous value!</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id) <span class=\"comment\">// returning a promise!</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>是不是很赞？第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。</p>\n<p>不幸的是，有一个不便的现实是在 JavaScript 中无返回值函数在技术上是返回 undefined，这就意味着当你本意是返回某些值时，你很容易会不经意间引入副作用。</p>\n<p>出于这个原因，我个人养成了在 then() 函数内部 永远返回或抛出 的习惯。我建议你也这样做。</p>\n<h3 id=\"抛出同步异常\"><a href=\"#抛出同步异常\" class=\"headerlink\" title=\"抛出同步异常\"></a>抛出同步异常</h3><p>谈到 throw，这是让 promises 更加赞的一点。比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>) <span class=\"comment\">// throwing a synchronous error!</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> inMemoryCache[user.id]       <span class=\"comment\">// returning a synchronous value!</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)   <span class=\"comment\">// returning a promise!</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Boo, I got an error!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。</p>\n<p>这种特性非常有用，因此它能够在开发过程中帮助定位代码问题。举例来说，如果在 then() 函数内部中的任何地方，我们执行 JSON.parse()，如果 JSON 格式是错误的，那么它就会抛出一个异常。如果是使用回调风格，这个错误很可能就会被吃掉，但是使用 promises，我们可以轻易的在 catch() 函数中处理它了。</p>\n<h1 id=\"进阶错误\"><a href=\"#进阶错误\" class=\"headerlink\" title=\"进阶错误\"></a>进阶错误</h1><p>好了，现在你已经了解了让 promises 变的超级简单的技巧，现在让我们聊一聊一些特殊场景。<br>这些错误之所以被我归类为 “进阶” ，是因为我只见过这些错误发生在对 promises 已经有相当深入了解的开发者身上。但是为了解决文章最开始的谜题，我们必须讨论一下这些错误。</p>\n<h3 id=\"进阶错误-1：不知道-Promise-resolve\"><a href=\"#进阶错误-1：不知道-Promise-resolve\" class=\"headerlink\" title=\"进阶错误 #1：不知道 Promise.resolve()\"></a>进阶错误 #1：不知道 Promise.resolve()</h3><p>如我上面所列举的，promises 在封装同步与异步代码时非常的有用。然而，如果你发现你经常写出下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    resolve(someSynchronousValue)</div><div class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</div></pre></td></tr></table></figure>\n<p>你会发现使用 Promise.resolve 会更加简洁：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(someSynchronousValue).then(<span class=\"comment\">/* ... */</span>);</div></pre></td></tr></table></figure>\n<p>它在用来捕获同步异常时也极其的好用。由于它实在是好用，因此我已经养成了在我所有 promise 形式的 API 接口中这样使用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseAPI</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        doSomethingThatMayThrow()</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span></div><div class=\"line\">    &#125;).then(<span class=\"comment\">/* ... */</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>切记：任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。</p>\n<p>类似的，还有 Promise.reject() 你可以用来返回一个立刻返回失败的 promise。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some awful error'</span>));</div></pre></td></tr></table></figure>\n<h3 id=\"进阶错误-2：catch-与-then-null-…-并非完全等价\"><a href=\"#进阶错误-2：catch-与-then-null-…-并非完全等价\" class=\"headerlink\" title=\"进阶错误 #2：catch() 与 then(null, …) 并非完全等价\"></a>进阶错误 #2：catch() 与 then(null, …) 并非完全等价</h3><p>之前我说过 catch() 仅仅是一个语法糖。因此下面两段代码是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，这并不意味着下面两段代码是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> someOtherPromise();</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> someOtherPromise();</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你好奇为何这两段代码并不等价，可以考虑一下如果第一个函数抛出异常会发生什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>)</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I caught your error! :)</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>)</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I didn't catch your error! :(</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>因此，当你使用 then(resolveHandler, rejectHandler) 这种形式时，rejectHandler 并不会捕获由 resolveHandler 引发的异常。</p>\n<p>鉴于此，我个人的习惯是不适用 then() 的第二个参数，而是总是使用 catch()。唯一的例外是当我写一些异步的 Mocha 测试用例时，我可能会希望用例的异常可以正确的被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'should throw an error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomethingThatThrows().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'I expected an error!'</span>)</div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">        should.exist(err)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>说到这里，<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"external\">Mocha</a> 和 <a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"external\">Chai</a> 用来测试 promise 接口时，是一对非常好的组合。 <a href=\"https://github.com/pouchdb/plugin-seed\" target=\"_blank\" rel=\"external\">pouchdb-plugin-seed</a> 项目中有一些 <a href=\"https://github.com/pouchdb/plugin-seed/blob/master/test/test.js\" target=\"_blank\" rel=\"external\">示例</a> 可以帮助你入门。</p>\n<h3 id=\"进阶错误-3：promises-vs-promises-factories\"><a href=\"#进阶错误-3：promises-vs-promises-factories\" class=\"headerlink\" title=\"进阶错误 #3：promises vs promises factories\"></a>进阶错误 #3：promises vs promises factories</h3><p>当我们希望执行一个个的执行一个 promises 序列，即类似 Promise.all() 但是并非并行的执行所有 promises。</p>\n<p>你可能天真的写下这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promises</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise</span>) </span>&#123;</div><div class=\"line\">        result = result.then(promise)</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不幸的是，这份代码不会按照你的期望去执行，你传入 executeSequentially() 的 promises 依然会并行执行。</p>\n<p>其根源在于你所希望的，实际上根本不是去执行一个 promises 序列。依照 promises 规范，一旦一个 promise 被创建，它就被执行了。因此你实际上需要的是一个 promise factories 数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">    promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promiseFactory</span>) </span>&#123;</div><div class=\"line\">        result = result.then(promiseFactory)</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我知道你在想什么：“这是哪个见鬼的 Java 程序猿，他为啥在说 factories？” 。实际上，一个 promises factory 是十分简单的，它仅仅是一个可以返回 promise 的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromiseFactory</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> somethingThatCreatesAPromise();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为何这样就可以了？这是因为一个 promise factory 在被执行之前并不会创建 promise。它就像一个 then 函数一样，而实际上，它们就是完全一样的东西。</p>\n<p>如果你查看上面的 executeSequentially() 函数，然后想象 myPromiseFactory 被包裹在 result.then(…) 之中，也许你脑中的小灯泡就会亮起。在此时此刻，对于 promise 你就算是悟道了。</p>\n<h3 id=\"进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办\"><a href=\"#进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办\" class=\"headerlink\" title=\"进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办\"></a>进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办</h3><p>有时候，一个 promise 会依赖于另一个，但是如果我们希望同时获得这两个 promises 的输出。举例来说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// dangit, I need the \"user\" object too!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>为了成为一个优秀的 Javascript 开发者，并且避免金字塔问题，我们可能会将 user 对象存在一个更高的作用域中的变量里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user</div><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    user = result</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// okay, I have both the \"user\" and the \"userAccount\"</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样是没问题的，但是我个人认为这样做有些杂牌。我推荐的策略是抛弃成见，拥抱金字塔：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// okay, I have both the \"user\" and the \"userAccount\"</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>…至少暂时这样是没问题的。一旦缩进开始成为问题，你可以通过 Javascript 开发者从远古时期就开始使用的技巧，将函数抽离到一个命名函数中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUserAndUserAccount</span>(<span class=\"params\">user, userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomething(user, userAccount)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUser</span>(<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> onGetUserAndUserAccount(user, userAccount)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>)</div><div class=\"line\">.then(onGetUser)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// at this point, doSomething() is done, and we are back to indentation 0</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>由于你的 promise 代码开始变得更加复杂，你可能发现自己开始将越来越多的函数抽离到命名函数中，我发现这样做，你的代码会越来越漂亮，就像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">putYourRightFootIn()</div><div class=\"line\">.then(putYourRightFootOut)</div><div class=\"line\">.then(putYourRightFootIn)</div><div class=\"line\">.then(shakeItAllAbout)</div></pre></td></tr></table></figure>\n<p><code>这就是 promises 的重点。</code></p>\n<h3 id=\"进阶错误-5：promises-穿透\"><a href=\"#进阶错误-5：promises-穿透\" class=\"headerlink\" title=\"进阶错误 #5：promises 穿透\"></a>进阶错误 #5：promises 穿透</h3><p>最后，这个错误就是我开头说的 promises 谜题所影射的错误。这是一个非常稀有的用例，并且可能完全不会出现在你的代码中，但是的的确确震惊了我。</p>\n<p>你认为下面的代码会打印出什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</div><div class=\"line\">.then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你认为它会打印出 bar，那么你就错了。它实际上打印出来的是 foo！</p>\n<p>发生这个的原因是如果你像 then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。你可以自己测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</div><div class=\"line\">.then(<span class=\"literal\">null</span>)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>添加任意数量的 then(null)，它依然会打印 foo。</p>\n<p>这实际上又回到了我之前说的 promises vs promise factories。简单的说，你可以直接传递一个 promise 到 then() 函数中，但是它并不会按照你期望的去执行。then() 是期望获取一个函数，因此你希望做的最可能是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样他就会如我们所想的打印出 bar。</p>\n<p><code>因此记住：永远都是往 then() 中传递函数！</code></p>\n<h3 id=\"期待-async-await\"><a href=\"#期待-async-await\" class=\"headerlink\" title=\"期待 async/await\"></a>期待 async/await</h3><p>在 “<a href=\"https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html\" target=\"_blank\" rel=\"external\">Taming the asynchronous beast with ES7</a>” 中提到的重点，在这篇文章中我探究了 ES7 的 async/await 关键字，以及它们是如何将 promises 更深度的结合入语言。不再会要求我们去编写伪同步的代码（以及一个假的 catch() 函数，虽然像，但是并非是 catch），ES7 将会允许我们使用真正的 try/catch/return 关键字，就像我们在 CS 101 上学的一样。</p>\n<p>这对于 Javascript 语言来说是一个大福音。因为即使到最后，只要我们的工具不告诉我们做错了，这些 promise 反模式依然会一直出现。</p>\n<p>从 JavaScript 的历史来看，我认为公正的评价来说 JSLint 与 JSHint 对社区的贡献是高于 JavaScript: The Good Parts 的，虽然他们包含的信息实际上是相同的。但是它们的区别在于 被告知你在你代码中犯的错误 与你去阅读一本书籍，去理解其他人犯的错误。</p>\n<p>ES7 的 async/await 的美妙在于，你的错误会被作为语法或者编译器错误提示出来，而不是运行时的 bug。不过就目前而言，了解 promise 可以做什么以及如何在 ES5 与 ES6 中正确的使用它们依然是有必要的。</p>\n<p>因此当我意识到，就像 JavaScript: The Good Parts 一样，这篇博文可能只会有非常有限的影响的时候，我希望当你发现其他人在犯同样的错误的时候，你可以将这篇博文提供给他们。因为现在依然有很多同学需要承认: “I have a problem with promises!”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.all is good for executing many promises at once</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.all([</div><div class=\"line\">  promise1,</div><div class=\"line\">  promise2</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.resolve is good for wrapping synchronous code</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (somethingIsNotRight()) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"I will be rejected asynchronously!\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"This string will be resolved asynchronously!\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// execute some promises one after the other.</span></div><div class=\"line\"><span class=\"comment\">// this takes an array of promise factories, i.e.</span></div><div class=\"line\"><span class=\"comment\">// an array of functions that RETURN a promise</span></div><div class=\"line\"><span class=\"comment\">// (not an array of promises themselves; those would execute immediately)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialize</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> chain = <span class=\"built_in\">Promise</span>.resolve();</div><div class=\"line\">  promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promiseFactory</span>) </span>&#123;</div><div class=\"line\">    chain = chain.then(promiseFactory);</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> chain;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.race is good for setting a timeout:</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.race([</div><div class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    setTimeout(reject, <span class=\"number\">10000</span>); <span class=\"comment\">// timeout after 10 secs</span></div><div class=\"line\">  &#125;),</div><div class=\"line\">  doSomethingThatMayTakeAwhile()</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise finally util similar to Q.finally</span></div><div class=\"line\"><span class=\"comment\">// e.g. promise.then(...).catch().then(...).finally(...)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finally</span> (<span class=\"params\">promise, cb</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> promise2 = cb();</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise2.then === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> promise2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> promise2 = cb();</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise2.then === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> promise2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> reason;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">throw</span> reason;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"下面四种Promise的区别\"><a href=\"#下面四种Promise的区别\" class=\"headerlink\" title=\"下面四种Promise的区别\"></a><em>下面四种Promise的区别</em></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">doSomething().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomethingElse()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">doSomething().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    doSomethingElse()</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">doSomething().then(doSomethingElse())</div><div class=\"line\"></div><div class=\"line\">doSomething().then(doSomethingElse)</div></pre></td></tr></table></figure>\n<h2 id=\"Promise的起源\"><a href=\"#Promise的起源\" class=\"headerlink\" title=\"Promise的起源\"></a>Promise的起源</h2><p>如果你阅读了 promises 的一些相关文献，你会发现有一个词 <a href=\"https://medium.com/@wavded/managing-node-js-callback-hell-1fe03ba8baf#.ca5u6o9fl\" target=\"_blank\" rel=\"external\">金字塔问题</a> 经常出现。它描述的是大量的回调函数慢慢向右侧屏幕延伸的一种状态。</p>\n<p>Promises 的确解决了这个问题，并且不仅仅是缩进问题。就像在 <a href=\"http://youtu.be/hf1T_AONQJU\" target=\"_blank\" rel=\"external\">Callback Hell的救赎</a> 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。相反，我们的整个代码流程都是基于副作用的: 一个函数会附带调用其他函数。</p>\n<blockquote>\n<p>原文关于副作用的描述并不能很直观的进行理解，建议参考 <a href=\"https://en.wikipedia.org/wiki/Side_effect_(computer_science\" target=\"_blank\" rel=\"external\">WIKI</a>) 。简单来说就是一个函数除了会返回一个值之外，还会修改函数以外的状态如全局变量等等。实际上所有异步调用都可以视为带有副作用的行为。</p>\n</blockquote>\n<p>并且实际上，回调更加恼人的是，他会将我们通常在大部分编程语言中能获得的<em>堆栈</em>破坏。编写代码时如果无法获取堆栈就像开车时没有刹车一样: 不到用的时候，你不会知道它有多重要。</p>\n<p>Promises 给予我们的就是在我们使用异步时丢失的最重要的语言基石: return, throw 以及堆栈。但是想要 promises 能够提供这些便利给你的前提是你知道如何正确的使用它们。</p>\n<h2 id=\"新手错误\"><a href=\"#新手错误\" class=\"headerlink\" title=\"新手错误\"></a>新手错误</h2><p>Promise对于不同的人有不同的理解和观点，但是这篇文章我特质<a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"external\">正式标准</a>, 在现代浏览器中暴露为window.Promise。虽然并非所有浏览器都有windows.Promise,但是可以寻找一些pollyfill,比如<a href=\"https://github.com/calvinmetcalf/lie\" target=\"_blank\" rel=\"external\">Lie</a>、<a href=\"https://github.com/petkaantonov/bluebird\" target=\"_blank\" rel=\"external\">bluebird</a>。</p>\n<h3 id=\"新手错误-1：-promise版的金字塔问题\"><a href=\"#新手错误-1：-promise版的金字塔问题\" class=\"headerlink\" title=\"新手错误 #1： promise版的金字塔问题\"></a>新手错误 #1： promise版的金字塔问题</h3><p>观察大家如何使用 PouchDB 这类大型的 promise 风格的API，我发现大量错误的 promise 使用形式。最常见的错误就是下面这个:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">remotedb.allDocs(&#123;</div><div class=\"line\">    <span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">attachments</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> docs = result.rows;</div><div class=\"line\">    docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">        localdb.put(element.doc).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</div><div class=\"line\">            alert(<span class=\"string\">'Pulled doc with id '</span> + element.doc._id + <span class=\"string\">' and added to local db.'</span>);</div><div class=\"line\">        &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (err.status == <span class=\"number\">409</span>) &#123;</div><div class=\"line\">                localdb.get(element.doc._id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resp</span>) </span>&#123;</div><div class=\"line\">                    localdb.remove(resp._id, resp._rev).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resp</span>) </span>&#123;</div><div class=\"line\">                            <span class=\"comment\">// et cetera...</span></div><div class=\"line\">                    &#125;)</div><div class=\"line\">                &#125;)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>是的，实际上你可以像使用回调一样使用 promises，恩，就像用打磨机去削脚趾甲一样，你确实可以这么做。</p>\n<p>并且如果你以为这样的错误只限于初学者，那么你会惊讶于我实际上是在黑莓官方开发者博客上看到上面的代码。老的回调风格的习惯难以消灭。(至开发者: 抱歉选了你的例子，但是你的例子将会有积极的教育意义)</p>\n<p>正确的风格应该是:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">remotedb.allDocs(...).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfAllDocs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.put(...)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfPut</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.get(...)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resultOfGet</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> localdb.put(...)</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(err)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用，稍后我们在这块做更多的讨论。</p>\n<h3 id=\"新手错误-2：-WTF-用了-promises-后怎么用-forEach\"><a href=\"#新手错误-2：-WTF-用了-promises-后怎么用-forEach\" class=\"headerlink\" title=\"新手错误 #2： WTF, 用了 promises 后怎么用 forEach?\"></a>新手错误 #2： WTF, 用了 promises 后怎么用 forEach?</h3><p>这里是大多数人对于 promises 的理解开始出现偏差。一旦当他们要使用他们熟悉的 forEach() 循环 (无论是 for 循环还是 while 循环)，他们完全不知道如何将 promises 与其一起使。因此他们就会写下类似这样的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// I want to remove() all docs</span></div><div class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    result.rows.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">row</span>) </span>&#123;</div><div class=\"line\">        db.remove(row.doc)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I naively believe all docs have been removed() now!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这份代码有什么问题？问题在于第一个函数实际上返回的是 undefined，这意味着第二个方法不会等待所有 documents 都执行 db.remove()。实际上他不会等待任何事情，并且可能会在任意数量的文档被删除后执行！</p>\n<p>这是一个非常隐蔽的 bug，因为如果 PouchDB 删除这些文档足够快，你的 UI 界面上显示的会完成正常，你可能会完全注意不到有什么东西有错误。这个 bug 可能会在一些古怪的竞态问题或一些特定的浏览器中暴露出来，并且到时可能几乎没有可能去定位问题。</p>\n<p>简而言之，forEach()/for/while 并非你寻找的解决方案。你需要的是 Promise.all():</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.allDocs(&#123;<span class=\"attr\">include_docs</span>: <span class=\"literal\">true</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(result.rows.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">row</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> db.remove(row.doc)</div><div class=\"line\">    &#125;))</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">arrayOfResults</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// All docs have really been removed() now!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面的代码是什么意思呢？大体来说，Promise.all()会以一个 promises 数组为输入，并且返回一个新的 promise。这个新的 promise 会在数组中所有的 promises 都成功返回后才返回。他是异步版的 for 循环。</p>\n<p>并且 Promise.all() 会将执行结果组成的数组返回到下一个函数，比如当你希望从 PouchDB 中获取多个对象时，会非常有用。此外一个更加有用的特效是，一旦数组中的 promise 任意一个返回错误，Promise.all() 也会返回错误。</p>\n<h3 id=\"新手错误-3：-忘记使用-catch\"><a href=\"#新手错误-3：-忘记使用-catch\" class=\"headerlink\" title=\"新手错误 #3： 忘记使用 .catch()\"></a>新手错误 #3： 忘记使用 .catch()</h3><p>这是另一个常见的错误。单纯的坚信自己的 promises 会永远不出现异常，很多开发者会忘记在他们的代码中添加一个 .catch()。然而不幸的是这也意味着，任何被抛出的异常都会被吃掉，并且你无法在 console 中观察到他们。这类问题 debug 起来会非常痛苦。</p>\n<blockquote>\n<p>类似 Bluebird 之类的 Promise 库会在这种场景抛出 UnhandledRejectionError 警示有未处理的异常，这类情况一旦发现，就会造成脚本异常，在 Node 中更会造成进程 Crash 的问题，因此正确的添加 .catch() 非常重要。 译者注</p>\n</blockquote>\n<p>为了避免这类讨厌的场景，我习惯于像下面的代码一样使用 promise:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> anotherPromise();</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> yetAnotherPromise();</div><div class=\"line\">&#125;).catch(<span class=\"built_in\">console</span>.log.bind(<span class=\"built_in\">console</span>)); <span class=\"comment\">// &lt;-- this is badass</span></div></pre></td></tr></table></figure>\n<p>即使你坚信不会出现异常，添加一个 catch() 总归是更加谨慎的。如果你的假设最终被发现是错误的，它会让你的生活更加美好。</p>\n<h3 id=\"新手错误-4：使用-“deferred”\"><a href=\"#新手错误-4：使用-“deferred”\" class=\"headerlink\" title=\"新手错误 #4：使用 “deferred”\"></a>新手错误 #4：使用 “deferred”</h3><p>这是一个我经常可以看到的错误，以至于我甚至不愿意在这里重复它，就像惧怕 Beetlejuice 一样，仅仅是提到它的名字，就会召唤出来更多。</p>\n<p>简单的说，promises 拥有一个漫长并且戏剧化的历史，Javascript 社区花费了大量的时间让其走上正轨。在早期，deferred 在 Q，When，RSVP，Bluebird，Lie等等的 “优秀” 类库中被引入， jQuery 与 Angular 在使用 ES6 Promise 规范之前，都是使用这种模式编写代码。</p>\n<p>因此如果你在你的代码中使用了这个词 (我不会把这个词重复第三遍！)，你就做错了。下面是说明一下如何避免它。</p>\n<p>首先，大部分 promises 类库都会提供一个方式去包装一个第三方的 promises 对象。举例来说，Angular的 $q 模块允许你使用 $q.when 包裹非 $q 的 promises。因此 Angular 用户可以这样使用 PouchDB promises.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$q.when(db.put(doc)).then(<span class=\"comment\">/* ... */</span>); <span class=\"comment\">// &lt;-- this is all the code you need</span></div></pre></td></tr></table></figure>\n<p>另一种策略是使用<a href=\"https://blog.domenic.me/the-revealing-constructor-pattern/\" target=\"_blank\" rel=\"external\">构造函数声明模式</a>，它在用来包裹非 promise API 时非常有用。举例来说，为了包裹一个回调风格的 API 如 Node 的 fs.readFile ，你可以简单的这么做:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    fs.readFile(<span class=\"string\">'myfile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, file</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> reject(err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        resolve(file);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</div></pre></td></tr></table></figure>\n<p>完工！我们打败了可怕的 def….啊哈，抓到自己了。:)</p>\n<blockquote>\n<p>关于为何这是一种反模式更多的内容，请查看 Bluebird 的 <a href=\"https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern\" target=\"_blank\" rel=\"external\">promise anti-patterns</a> wiki 页</p>\n</blockquote>\n<h3 id=\"新手错误-5：使用副作用调用而非返回\"><a href=\"#新手错误-5：使用副作用调用而非返回\" class=\"headerlink\" title=\"新手错误 #5：使用副作用调用而非返回\"></a>新手错误 #5：使用副作用调用而非返回</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    someOtherPromise()</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Gee, I hope someOtherPromise() has resolved!</span></div><div class=\"line\">    <span class=\"comment\">// Spoiler alert: it hasn't.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>好了，现在是时候讨论一下关于 promises 你所需要知道的一切。</p>\n<p>认真的说，这是一个一旦你理解了它，就会避免所有我提及的错误的古怪的技巧。你准备好了么？</p>\n<p>就如我前面所说，promises 的奇妙在于给予我们以前的 return 与 throw。但是在实践中这到底是怎么一回事呢？</p>\n<p>每一个 promise 都会提供给你一个 then() 函数 (或是 catch()，实际上只是 then(null, …) 的语法糖)。当我们在 then() 函数内部时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I'm inside a then() function!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们可以做什么呢？有三种事情：</p>\n<p>return 另一个 promise<br>return 一个同步的值 (或者 undefined)<br>throw 一个同步异常<br>就是这样。一旦你理解了这个技巧，你就理解了 promises。因此让我们逐个了解下。</p>\n<p>返回另一个 promise<br>这是一个在 promise 文档中常见的使用模式，也就是我们在上文中提到的 “composing promises”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注意到我是 <code>return</code> 第二个 promise，这个 <code>return</code> 非常重要。如果我没有写 <code>return</code>，<code>getUserAccountById()</code> 就会成为一个副作用，并且下一个函数将会接收到 <code>undefined</code> 而非 <code>userAccount</code>。</p>\n</blockquote>\n<h3 id=\"返回一个同步值-或者-undefined\"><a href=\"#返回一个同步值-或者-undefined\" class=\"headerlink\" title=\"返回一个同步值 (或者 undefined)\"></a>返回一个同步值 (或者 undefined)</h3><p>返回 undefined 通常是错误的，但是返回一个同步值实际上是将同步代码包裹为 promise 风格代码的一种非常赞的手段。举例来说，我们对 users 信息有一个内存缓存。我们可以这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> inMemoryCache[user.id]    <span class=\"comment\">// returning a synchronous value!</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id) <span class=\"comment\">// returning a promise!</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>是不是很赞？第二个函数不需要关心 userAccount 是从同步方法还是异步方法中获取的，并且第一个函数可以非常自由的返回一个同步或者异步值。</p>\n<p>不幸的是，有一个不便的现实是在 JavaScript 中无返回值函数在技术上是返回 undefined，这就意味着当你本意是返回某些值时，你很容易会不经意间引入副作用。</p>\n<p>出于这个原因，我个人养成了在 then() 函数内部 永远返回或抛出 的习惯。我建议你也这样做。</p>\n<h3 id=\"抛出同步异常\"><a href=\"#抛出同步异常\" class=\"headerlink\" title=\"抛出同步异常\"></a>抛出同步异常</h3><p>谈到 throw，这是让 promises 更加赞的一点。比如我们希望在用户已经登出时，抛出一个同步异常。这会非常简单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (user.isLoggedOut()) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'user logged out!'</span>) <span class=\"comment\">// throwing a synchronous error!</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (inMemoryCache[user.id]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> inMemoryCache[user.id]       <span class=\"comment\">// returning a synchronous value!</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)   <span class=\"comment\">// returning a promise!</span></div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I got a user account!</span></div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Boo, I got an error!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如果用户已经登出，我们的 catch() 会接收到一个同步异常，并且如果 后续的 promise 中出现异步异常，他也会接收到。再强调一次，这个函数并不需要关心这个异常是同步还是异步返回的。</p>\n<p>这种特性非常有用，因此它能够在开发过程中帮助定位代码问题。举例来说，如果在 then() 函数内部中的任何地方，我们执行 JSON.parse()，如果 JSON 格式是错误的，那么它就会抛出一个异常。如果是使用回调风格，这个错误很可能就会被吃掉，但是使用 promises，我们可以轻易的在 catch() 函数中处理它了。</p>\n<h1 id=\"进阶错误\"><a href=\"#进阶错误\" class=\"headerlink\" title=\"进阶错误\"></a>进阶错误</h1><p>好了，现在你已经了解了让 promises 变的超级简单的技巧，现在让我们聊一聊一些特殊场景。<br>这些错误之所以被我归类为 “进阶” ，是因为我只见过这些错误发生在对 promises 已经有相当深入了解的开发者身上。但是为了解决文章最开始的谜题，我们必须讨论一下这些错误。</p>\n<h3 id=\"进阶错误-1：不知道-Promise-resolve\"><a href=\"#进阶错误-1：不知道-Promise-resolve\" class=\"headerlink\" title=\"进阶错误 #1：不知道 Promise.resolve()\"></a>进阶错误 #1：不知道 Promise.resolve()</h3><p>如我上面所列举的，promises 在封装同步与异步代码时非常的有用。然而，如果你发现你经常写出下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    resolve(someSynchronousValue)</div><div class=\"line\">&#125;).then(<span class=\"comment\">/* ... */</span>)</div></pre></td></tr></table></figure>\n<p>你会发现使用 Promise.resolve 会更加简洁：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(someSynchronousValue).then(<span class=\"comment\">/* ... */</span>);</div></pre></td></tr></table></figure>\n<p>它在用来捕获同步异常时也极其的好用。由于它实在是好用，因此我已经养成了在我所有 promise 形式的 API 接口中这样使用它：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseAPI</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        doSomethingThatMayThrow()</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span></div><div class=\"line\">    &#125;).then(<span class=\"comment\">/* ... */</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>切记：任何有可能 throw 同步异常的代码都是一个后续会导致几乎无法调试异常的潜在因素。但是如果你将所有代码都使用 Promise.resolve() 封装，那么你总是可以在之后使用 catch() 来捕获它。</p>\n<p>类似的，还有 Promise.reject() 你可以用来返回一个立刻返回失败的 promise。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'some awful error'</span>));</div></pre></td></tr></table></figure>\n<h3 id=\"进阶错误-2：catch-与-then-null-…-并非完全等价\"><a href=\"#进阶错误-2：catch-与-then-null-…-并非完全等价\" class=\"headerlink\" title=\"进阶错误 #2：catch() 与 then(null, …) 并非完全等价\"></a>进阶错误 #2：catch() 与 then(null, …) 并非完全等价</h3><p>之前我说过 catch() 仅仅是一个语法糖。因此下面两段代码是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，这并不意味着下面两段代码是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> someOtherPromise();</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> someOtherPromise();</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// handle error</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你好奇为何这两段代码并不等价，可以考虑一下如果第一个函数抛出异常会发生什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>)</div><div class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I caught your error! :)</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">somePromise().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'oh noes'</span>)</div><div class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// I didn't catch your error! :(</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>因此，当你使用 then(resolveHandler, rejectHandler) 这种形式时，rejectHandler 并不会捕获由 resolveHandler 引发的异常。</p>\n<p>鉴于此，我个人的习惯是不适用 then() 的第二个参数，而是总是使用 catch()。唯一的例外是当我写一些异步的 Mocha 测试用例时，我可能会希望用例的异常可以正确的被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">it(<span class=\"string\">'should throw an error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomethingThatThrows().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'I expected an error!'</span>)</div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">        should.exist(err)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>说到这里，<a href=\"http://mochajs.org/\" target=\"_blank\" rel=\"external\">Mocha</a> 和 <a href=\"http://chaijs.com/\" target=\"_blank\" rel=\"external\">Chai</a> 用来测试 promise 接口时，是一对非常好的组合。 <a href=\"https://github.com/pouchdb/plugin-seed\" target=\"_blank\" rel=\"external\">pouchdb-plugin-seed</a> 项目中有一些 <a href=\"https://github.com/pouchdb/plugin-seed/blob/master/test/test.js\" target=\"_blank\" rel=\"external\">示例</a> 可以帮助你入门。</p>\n<h3 id=\"进阶错误-3：promises-vs-promises-factories\"><a href=\"#进阶错误-3：promises-vs-promises-factories\" class=\"headerlink\" title=\"进阶错误 #3：promises vs promises factories\"></a>进阶错误 #3：promises vs promises factories</h3><p>当我们希望执行一个个的执行一个 promises 序列，即类似 Promise.all() 但是并非并行的执行所有 promises。</p>\n<p>你可能天真的写下这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promises</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">    promises.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise</span>) </span>&#123;</div><div class=\"line\">        result = result.then(promise)</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不幸的是，这份代码不会按照你的期望去执行，你传入 executeSequentially() 的 promises 依然会并行执行。</p>\n<p>其根源在于你所希望的，实际上根本不是去执行一个 promises 序列。依照 promises 规范，一旦一个 promise 被创建，它就被执行了。因此你实际上需要的是一个 promise factories 数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeSequentially</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"built_in\">Promise</span>.resolve()</div><div class=\"line\">    promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promiseFactory</span>) </span>&#123;</div><div class=\"line\">        result = result.then(promiseFactory)</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我知道你在想什么：“这是哪个见鬼的 Java 程序猿，他为啥在说 factories？” 。实际上，一个 promises factory 是十分简单的，它仅仅是一个可以返回 promise 的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myPromiseFactory</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> somethingThatCreatesAPromise();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为何这样就可以了？这是因为一个 promise factory 在被执行之前并不会创建 promise。它就像一个 then 函数一样，而实际上，它们就是完全一样的东西。</p>\n<p>如果你查看上面的 executeSequentially() 函数，然后想象 myPromiseFactory 被包裹在 result.then(…) 之中，也许你脑中的小灯泡就会亮起。在此时此刻，对于 promise 你就算是悟道了。</p>\n<h3 id=\"进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办\"><a href=\"#进阶错误-4：好了，如果我希望获得两个-promises-的结果怎么办\" class=\"headerlink\" title=\"进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办\"></a>进阶错误 #4：好了，如果我希望获得两个 promises 的结果怎么办</h3><p>有时候，一个 promise 会依赖于另一个，但是如果我们希望同时获得这两个 promises 的输出。举例来说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// dangit, I need the \"user\" object too!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>为了成为一个优秀的 Javascript 开发者，并且避免金字塔问题，我们可能会将 user 对象存在一个更高的作用域中的变量里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> user</div><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    user = result</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// okay, I have both the \"user\" and the \"userAccount\"</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样是没问题的，但是我个人认为这样做有些杂牌。我推荐的策略是抛弃成见，拥抱金字塔：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// okay, I have both the \"user\" and the \"userAccount\"</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>…至少暂时这样是没问题的。一旦缩进开始成为问题，你可以通过 Javascript 开发者从远古时期就开始使用的技巧，将函数抽离到一个命名函数中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUserAndUserAccount</span>(<span class=\"params\">user, userAccount</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> doSomething(user, userAccount)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onGetUser</span>(<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> getUserAccountById(user.id).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">userAccount</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> onGetUserAndUserAccount(user, userAccount)</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">getUserByName(<span class=\"string\">'nolan'</span>)</div><div class=\"line\">.then(onGetUser)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// at this point, doSomething() is done, and we are back to indentation 0</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>由于你的 promise 代码开始变得更加复杂，你可能发现自己开始将越来越多的函数抽离到命名函数中，我发现这样做，你的代码会越来越漂亮，就像这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">putYourRightFootIn()</div><div class=\"line\">.then(putYourRightFootOut)</div><div class=\"line\">.then(putYourRightFootIn)</div><div class=\"line\">.then(shakeItAllAbout)</div></pre></td></tr></table></figure>\n<p><code>这就是 promises 的重点。</code></p>\n<h3 id=\"进阶错误-5：promises-穿透\"><a href=\"#进阶错误-5：promises-穿透\" class=\"headerlink\" title=\"进阶错误 #5：promises 穿透\"></a>进阶错误 #5：promises 穿透</h3><p>最后，这个错误就是我开头说的 promises 谜题所影射的错误。这是一个非常稀有的用例，并且可能完全不会出现在你的代码中，但是的的确确震惊了我。</p>\n<p>你认为下面的代码会打印出什么？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</div><div class=\"line\">.then(<span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>如果你认为它会打印出 bar，那么你就错了。它实际上打印出来的是 foo！</p>\n<p>发生这个的原因是如果你像 then() 传递的并非是一个函数（比如 promise），它实际上会将其解释为 then(null)，这就会导致前一个 promise 的结果会穿透下面。你可以自己测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>)</div><div class=\"line\">.then(<span class=\"literal\">null</span>)</div><div class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>添加任意数量的 then(null)，它依然会打印 foo。</p>\n<p>这实际上又回到了我之前说的 promises vs promise factories。简单的说，你可以直接传递一个 promise 到 then() 函数中，但是它并不会按照你期望的去执行。then() 是期望获取一个函数，因此你希望做的最可能是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'foo'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'bar'</span>)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(result)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样他就会如我们所想的打印出 bar。</p>\n<p><code>因此记住：永远都是往 then() 中传递函数！</code></p>\n<h3 id=\"期待-async-await\"><a href=\"#期待-async-await\" class=\"headerlink\" title=\"期待 async/await\"></a>期待 async/await</h3><p>在 “<a href=\"https://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html\" target=\"_blank\" rel=\"external\">Taming the asynchronous beast with ES7</a>” 中提到的重点，在这篇文章中我探究了 ES7 的 async/await 关键字，以及它们是如何将 promises 更深度的结合入语言。不再会要求我们去编写伪同步的代码（以及一个假的 catch() 函数，虽然像，但是并非是 catch），ES7 将会允许我们使用真正的 try/catch/return 关键字，就像我们在 CS 101 上学的一样。</p>\n<p>这对于 Javascript 语言来说是一个大福音。因为即使到最后，只要我们的工具不告诉我们做错了，这些 promise 反模式依然会一直出现。</p>\n<p>从 JavaScript 的历史来看，我认为公正的评价来说 JSLint 与 JSHint 对社区的贡献是高于 JavaScript: The Good Parts 的，虽然他们包含的信息实际上是相同的。但是它们的区别在于 被告知你在你代码中犯的错误 与你去阅读一本书籍，去理解其他人犯的错误。</p>\n<p>ES7 的 async/await 的美妙在于，你的错误会被作为语法或者编译器错误提示出来，而不是运行时的 bug。不过就目前而言，了解 promise 可以做什么以及如何在 ES5 与 ES6 中正确的使用它们依然是有必要的。</p>\n<p>因此当我意识到，就像 JavaScript: The Good Parts 一样，这篇博文可能只会有非常有限的影响的时候，我希望当你发现其他人在犯同样的错误的时候，你可以将这篇博文提供给他们。因为现在依然有很多同学需要承认: “I have a problem with promises!”</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.all is good for executing many promises at once</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.all([</div><div class=\"line\">  promise1,</div><div class=\"line\">  promise2</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.resolve is good for wrapping synchronous code</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (somethingIsNotRight()) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"I will be rejected asynchronously!\"</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"This string will be resolved asynchronously!\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// execute some promises one after the other.</span></div><div class=\"line\"><span class=\"comment\">// this takes an array of promise factories, i.e.</span></div><div class=\"line\"><span class=\"comment\">// an array of functions that RETURN a promise</span></div><div class=\"line\"><span class=\"comment\">// (not an array of promises themselves; those would execute immediately)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequentialize</span>(<span class=\"params\">promiseFactories</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> chain = <span class=\"built_in\">Promise</span>.resolve();</div><div class=\"line\">  promiseFactories.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promiseFactory</span>) </span>&#123;</div><div class=\"line\">    chain = chain.then(promiseFactory);</div><div class=\"line\">  &#125;);</div><div class=\"line\">  <span class=\"keyword\">return</span> chain;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise.race is good for setting a timeout:</span></div><div class=\"line\"><span class=\"built_in\">Promise</span>.race([</div><div class=\"line\">  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</div><div class=\"line\">    setTimeout(reject, <span class=\"number\">10000</span>); <span class=\"comment\">// timeout after 10 secs</span></div><div class=\"line\">  &#125;),</div><div class=\"line\">  doSomethingThatMayTakeAwhile()</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Promise finally util similar to Q.finally</span></div><div class=\"line\"><span class=\"comment\">// e.g. promise.then(...).catch().then(...).finally(...)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finally</span> (<span class=\"params\">promise, cb</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> promise2 = cb();</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise2.then === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> promise2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> res;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> res;</div><div class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reason</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> promise2 = cb();</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> promise2.then === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> promise2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> reason;</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">throw</span> reason;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Example Post","date":"2014-09-21T16:00:00.000Z","author":"Hux","header-img":"post-bg-js-version.jpg","_content":"\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)   \n译者 [黄玄](http://weibo.com/huxpro)，首次发布于 [Hux Blog](http://huangxuan.me)，转载请保留以上链接\n","source":"_posts/js-version.markdown","raw":"---\nlayout:     post\ntitle:      \"Example Post\"\ndate:       2014-09-22\nauthor:     \"Hux\"\nheader-img: \"post-bg-js-version.jpg\"\ntags:\n    - 前端开发\n    - JavaScript\n    - 翻译\n---\n\n\nJavaScript 有着很奇怪的命名史。\n\n1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript *（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）*\n\n![java-javascript](javascript-java.jpg)\n<small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small>\n\n> 译者注：[wikipedia 的 JavaScript 词条](https://en.wikipedia.org/wiki/JavaScript#History) 更详细的叙述了这段历史\n\n1996 年，网景将 JavaScript 提交给 [ECMA International（欧洲计算机制造商协会）](http://www.ecma-international.org/) 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。\n\n\n> 术语（译者注）：\n>\n> * *标准（Standard）*： 用于定义与其他事物区别的一套规则\n> * *实现（Implementation）*： 某个标准的具体实施/真实实践\n\n\n不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。\n\n> 译者注：[ECMAScript 第四版草案](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29)由于太过激进而被抛弃，Adobe 的 [ActionScript 3.0](https://en.wikipedia.org/wiki/ActionScript) 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）\n\n到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）\n\n目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 [decorators（装饰者）](https://github.com/wycats/javascript-decorators)，[async-await（async-await 异步编程模型）](https://github.com/lukehoban/ecmascript-asyncawait) 和 [static class properties（静态类属性）](https://github.com/jeffmo/es-class-properties)。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 [Babel 的官网](https://babeljs.io/docs/usage/experimental/) 上查看各个提案目前都在哪个阶段了。\n\n所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：\n\n* **ECMAScript**：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。\n* **JavaScript**：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。\n* **ECMAScript 5 (ES5)**：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。\n* **ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)**：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅[这张兼容性表](http://kangax.github.io/compat-table/es6/)来查看不同浏览器和工具的实现情况。\n* **ECMAScript 2016**：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定\n* **ECMAScript Proposals**：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。\n\n在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。\n\n#### 一些资源\n\n\n\n* TC39 的 [Github 仓库](https://github.com/tc39/ecma262)上可以看到所有目前公开的提案\n* 如果你还不熟悉 ES6，Babel 有一个[很不错的特性概览](https://babeljs.io/docs/learn-es2015/)\n* 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 [Exploring ES6](http://exploringjs.com/)和 Nicholas Zakas 的 [Understanding ECMAScript 6](https://leanpub.com/understandinges6)。Axel 的博客 [2ality](http://www.2ality.com/) 也是很不错的 ES6 资源\n\n<img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\" />\n<small class=\"img-hint\">来学 JavaScript 吧！</small>\n\n#### 著作权声明\n\n本文译自 [ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?](http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/)   \n译者 [黄玄](http://weibo.com/huxpro)，首次发布于 [Hux Blog](http://huangxuan.me)，转载请保留以上链接\n","slug":"js-version","published":1,"updated":"2017-05-27T07:31:52.000Z","comments":1,"photos":[],"link":"","_id":"cj36yugao000awkt72rtemu3c","content":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，首次发布于 <a href=\"http://huangxuan.me\" target=\"_blank\" rel=\"external\">Hux Blog</a>，转载请保留以上链接</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript 有着很奇怪的命名史。</p>\n<p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p>\n<p><img src=\"javascript-java.jpg\" alt=\"java-javascript\"><br><small class=\"img-hint\">歪果仁的笑话怎么一点都不好笑</small></p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/JavaScript#History\" target=\"_blank\" rel=\"external\">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p>\n</blockquote>\n<p>1996 年，网景将 JavaScript 提交给 <a href=\"http://www.ecma-international.org/\" target=\"_blank\" rel=\"external\">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p>\n<blockquote>\n<p>术语（译者注）：</p>\n<ul>\n<li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li>\n<li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li>\n</ul>\n</blockquote>\n<p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p>\n<blockquote>\n<p>译者注：<a href=\"https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29\" target=\"_blank\" rel=\"external\">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href=\"https://en.wikipedia.org/wiki/ActionScript\" target=\"_blank\" rel=\"external\">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p>\n</blockquote>\n<p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p>\n<p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"external\">decorators（装饰者）</a>，<a href=\"https://github.com/lukehoban/ecmascript-asyncawait\" target=\"_blank\" rel=\"external\">async-await（async-await 异步编程模型）</a> 和 <a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href=\"https://babeljs.io/docs/usage/experimental/\" target=\"_blank\" rel=\"external\">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p>\n<p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p>\n<ul>\n<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>\n<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>\n<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>\n<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href=\"http://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>\n<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>\n<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>\n</ul>\n<p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p>\n<h4 id=\"一些资源\"><a href=\"#一些资源\" class=\"headerlink\" title=\"一些资源\"></a>一些资源</h4><ul>\n<li>TC39 的 <a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"external\">Github 仓库</a>上可以看到所有目前公开的提案</li>\n<li>如果你还不熟悉 ES6，Babel 有一个<a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"external\">很不错的特性概览</a></li>\n<li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href=\"http://exploringjs.com/\" target=\"_blank\" rel=\"external\">Exploring ES6</a>和 Nicholas Zakas 的 <a href=\"https://leanpub.com/understandinges6\" target=\"_blank\" rel=\"external\">Understanding ECMAScript 6</a>。Axel 的博客 <a href=\"http://www.2ality.com/\" target=\"_blank\" rel=\"external\">2ality</a> 也是很不错的 ES6 资源</li>\n</ul>\n<p><img class=\"shadow\" width=\"320\" src=\"keep-calm-and-learn-javascript.png\"><br><small class=\"img-hint\">来学 JavaScript 吧！</small></p>\n<h4 id=\"著作权声明\"><a href=\"#著作权声明\" class=\"headerlink\" title=\"著作权声明\"></a>著作权声明</h4><p>本文译自 <a href=\"http://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/\" target=\"_blank\" rel=\"external\">ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?</a><br>译者 <a href=\"http://weibo.com/huxpro\" target=\"_blank\" rel=\"external\">黄玄</a>，首次发布于 <a href=\"http://huangxuan.me\" target=\"_blank\" rel=\"external\">Hux Blog</a>，转载请保留以上链接</p>\n"},{"layout":"post","title":"Example Post With Default Header Image","subtitle":"不适合人类阅读，非常水的自我笔记","date":"2015-04-13T16:00:00.000Z","author":"Hux","_content":"\n> This document is not completed and will be updated anytime.\n\n\n## Catagory\n\n1. [Unix](#unix)\n\t1. [Bell Labs](#bell-labs)\n\t2. [Xenix](#xenix)\n\t3. [BSD](#bsd)\n\t4. [FreeBSD & Apple](#freebsd--apple)\n\t5. [NeXTStep](#nextstep)\n\t6. [Darwin](#darwin)\n\t7. [POSIX](#posix)\n2. [Unix-like](#unix-like)\n\t1. [Single Unix Specification](#single-unix-specification)\n\t2. [Apple iOS](#apple-ios)\n\t3. [XNU Kernel](#xnu-kernel)\n3. [Linux](#linux)\n\t1. [Linux Kernel](#linux-kernel)\n\t2. [GNU Project](#gnu-project)\n\t3. [Android](#android)\n\t4. [Android Kernel](#android-kernel)\n\t5. [Android ROM](#android-rom)\n\t6. [Chrome OS](#chrome-os)\n\t7. [Chromium OS](#chromium-os)\n\n---\n\n## Unix\n\n\n> Unix is a **family** of multitasking, multiuser computer OS.\n\n\nDerive from the original **AT&T Unix**, Developed in the 1970s at **Bell Labs** (贝尔实验室), initially intended for use inside the **Bell System**.\n\n- #### Bell Labs\nBell 和 AT&A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。\n**C 语言也是 Bell Labs 的产物**，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。\n\n\n\nAT&T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both **academic** (最有有名的 BSD ) and **commercial** (Microsoft Xenix, IBM AIX, SunOS Solaris)\n\n- #### Xenix\n微软 1979 年从 AT&A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 **Windows NT**。\n\n- #### BSD\n**Barkeley Software Distribution**, also called Berkeley Unix. Today the term \"BSD\" is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)\n\t- **BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议**，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple's OS X and iOS ）\n\t- BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。\n\n- #### FreeBSD & Apple\nFreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 **Darwin** ，这个“达尔文”居然还是个开源系统，而且是 the Core of **Mac OS X** and **iOS**.\n\n- #### NeXTSTEP\nAn **object-oriented**, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an **OO aplication layer** and including several \"kits\".    \n大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 **NeXTSTEP 绝对是证明 Jobs 实力的作品。**\n\n- #### Darwin\n[Darwin](http://en.wikipedia.org/wiki/Darwin_(operating_system\\)), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of **POSIX**. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)  \n**所以说 Mac OS X 算是很正统 Unix 的了**\n\n- #### POSIX\n可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.\n\t- Fully POSIX compliant:\n\t\t- OS X\n\t\t- QNX OS (BlackBerry)\n\t- Mostly complicant:\n\t\t- Linux\n\t\t- OpenBSD/FreeBSD\n\t\t- Darwin (Core of **iOS** & OS X)\n\t\t- **Android**\n\t- Complicant via compatibility feature （通过兼容功能实现兼容）\n\t\t- Windows NT Kernel\n\t\t\t- Windows Server 2000, 2003, 2008, 2008 R2, 2012\n\t\t- Symbian OS (with PIPS)\n\t\t\t- Symbian was a closed-source OS.\n\n\n---\n\n## Unix-like\n\n> A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the **Single UNIX Specification**.\n\nThere is no standard for defining the term.  \n其实 Unix-like 是个相对模糊的概念：\n\n* 最狭义的 Unix 单指 Bell Labs's Unix\n* 稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X\n* 最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等\n\n#### Single UNIX Specification\nThe Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to **qualify for the name \"Unix\"**, like **POSIX**.\n\n#### Apple iOS\niOS is a **Unix-like OS based on Darwin(BSD)** and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, **making iOS not fully Unix-compatible either.**\n\nThe iOS kernal is **XNU**, the kernal of Darwin.\n\n#### XNU Kernel\nXNU, the acronym(首字母缩写) for ***X is Not Unix***, which is the **Computer OS Kernel** developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.\n\n\n---\n\n## Linux\n\n\n> Linux is a Unix-like and mostly POSIX-compliant computer OS.\n\n\n![Unix_timeline](http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png)\n\n\n#### Linux Kernel\n\n严格来讲，术语 Linux 只表示 [Linux Kernel](http://en.wikipedia.org/wiki/Linux_kernel) 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。\n\n但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）\n\n这类操作系统也被称为 **GNU/Linux**\n\n\n#### GNU Project\n\nThe GNU Project is a **free software, mass collaboration** project, which based on the following freedom rights:\n\n* Users are free to run the software, share (copy, distribute), study and modify it.\n* GNU software guarantees these freedom-rights legally (via its license).\n* So it is not only FREE but, more important, FREEDOM.\n\nIn order to ensure that the *entire* software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, **the operating system**, needed to be written.\n\nThis OS is decided to called **GNU (a recursive acronym meaning \"GNU is not Unix\")**. By 1992, the GNU Project had completed all of the major OS components except for their kernel, *GNU Hurd*.\n\nWith the release of the third-party **Linux Kernel**, started independently by *Linus Torvalds* in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS **composed completely of free software**.\n\nThough the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.\n\nAnyway, there eventually comes to the **GNU/Linux**\n\n\n* **GPL**: GNU General Public License\n* **GCC**: GNU Compiler Collection\n\n其他与 GPL 相关的自由/开源软件公共许可证：\n\n* [Mozilla Public License](http://en.wikipedia.org/wiki/Mozilla_Public_License)\n* [MIT License](http://en.wikipedia.org/wiki/MIT_License)\n* [BSD Public License](http://en.wikipedia.org/wiki/BSD_licenses)\n\t* GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭\n* [Apache License](http://en.wikipedia.org/wiki/Apache_License)\n\n![Public License](http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png)\n\n#### Android\n\nAndroid is a mobile OS based on **Linux Kernel**, so it's definitely **Unix-like**.  \n\n**Linux is under GPL so Android has to be open source**.\nAndroid's source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google *(GMS are all proprietary)*  \n\n#### Android Kernel\n\nAndroid's kernel is based on one of the Linux kernel's long-term support (LTS) branches.   \n\n**Android's variant of the Linux kernel** has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.\n\nAndroid Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。\n\n\n#### Android ROM\n\n既然提到 Android 就不得不提提 Android ROM\n\nROM 的本义实际上是只读内存：  \n\n**Read-only memory** (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is **mainly used to distribute firmware (固件)** (software that is very closely tied to specific hardware, and unlikely to need frequent updates).\n\nROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  \n\n* PROM (Programmable read-only memory)\n* EPROM (Erasable programmable read-only memory)\n* EEPROM (Electrically erasable programmable read-only memory)\n\t* Flash memory (闪存)\n\nFlash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。\n\n所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。\n\n所以在 wiki 里是没有 Android ROM 这个词条的，只有 [List of custom Android firmwares](http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares)\n\n> A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.\n\n各类 Android ROM 在 Android 词类下也都是属于 **Forks and distributions** 一类的。\n\n所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……**其实 ROM 和 Distribution OS 的界限是很模糊的**，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？\n\n#### Chrome OS\n\nChrome OS is an operating system based on the **Linux kernel** and designed by Google to work with web applications and installed applications.\n\n虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……\n\n* **Chrome Packaged Application** (Support working offline and installed)\n* **Android App Runtime** (run Android applications natively...fxxking awesome)\n\n平复一下激动的心情，还是回到正题来：\n\n#### Chromium OS\n\nChrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a **Linux distribution** designed by Google.\n\nFor Detail, Chromium OS based on [Gentoo Linux](http://en.wikipedia.org/wiki/Gentoo_Linux), emm...\n","source":"_posts/unix-linux-note.markdown","raw":"---\nlayout:     post\ntitle:      \"Example Post With Default Header Image\"\nsubtitle:   \"不适合人类阅读，非常水的自我笔记\"\ndate:       2015-04-14\nauthor:     \"Hux\"\n# header-img: \"post-bg-unix-linux.jpg\"\ntags:\n    - OS\n    - Unix\n    - Linux\n---\n\n> This document is not completed and will be updated anytime.\n\n\n## Catagory\n\n1. [Unix](#unix)\n\t1. [Bell Labs](#bell-labs)\n\t2. [Xenix](#xenix)\n\t3. [BSD](#bsd)\n\t4. [FreeBSD & Apple](#freebsd--apple)\n\t5. [NeXTStep](#nextstep)\n\t6. [Darwin](#darwin)\n\t7. [POSIX](#posix)\n2. [Unix-like](#unix-like)\n\t1. [Single Unix Specification](#single-unix-specification)\n\t2. [Apple iOS](#apple-ios)\n\t3. [XNU Kernel](#xnu-kernel)\n3. [Linux](#linux)\n\t1. [Linux Kernel](#linux-kernel)\n\t2. [GNU Project](#gnu-project)\n\t3. [Android](#android)\n\t4. [Android Kernel](#android-kernel)\n\t5. [Android ROM](#android-rom)\n\t6. [Chrome OS](#chrome-os)\n\t7. [Chromium OS](#chromium-os)\n\n---\n\n## Unix\n\n\n> Unix is a **family** of multitasking, multiuser computer OS.\n\n\nDerive from the original **AT&T Unix**, Developed in the 1970s at **Bell Labs** (贝尔实验室), initially intended for use inside the **Bell System**.\n\n- #### Bell Labs\nBell 和 AT&A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。\n**C 语言也是 Bell Labs 的产物**，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。\n\n\n\nAT&T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both **academic** (最有有名的 BSD ) and **commercial** (Microsoft Xenix, IBM AIX, SunOS Solaris)\n\n- #### Xenix\n微软 1979 年从 AT&A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 **Windows NT**。\n\n- #### BSD\n**Barkeley Software Distribution**, also called Berkeley Unix. Today the term \"BSD\" is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)\n\t- **BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议**，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple's OS X and iOS ）\n\t- BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。\n\n- #### FreeBSD & Apple\nFreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 **Darwin** ，这个“达尔文”居然还是个开源系统，而且是 the Core of **Mac OS X** and **iOS**.\n\n- #### NeXTSTEP\nAn **object-oriented**, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an **OO aplication layer** and including several \"kits\".    \n大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 **NeXTSTEP 绝对是证明 Jobs 实力的作品。**\n\n- #### Darwin\n[Darwin](http://en.wikipedia.org/wiki/Darwin_(operating_system\\)), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of **POSIX**. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)  \n**所以说 Mac OS X 算是很正统 Unix 的了**\n\n- #### POSIX\n可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.\n\t- Fully POSIX compliant:\n\t\t- OS X\n\t\t- QNX OS (BlackBerry)\n\t- Mostly complicant:\n\t\t- Linux\n\t\t- OpenBSD/FreeBSD\n\t\t- Darwin (Core of **iOS** & OS X)\n\t\t- **Android**\n\t- Complicant via compatibility feature （通过兼容功能实现兼容）\n\t\t- Windows NT Kernel\n\t\t\t- Windows Server 2000, 2003, 2008, 2008 R2, 2012\n\t\t- Symbian OS (with PIPS)\n\t\t\t- Symbian was a closed-source OS.\n\n\n---\n\n## Unix-like\n\n> A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the **Single UNIX Specification**.\n\nThere is no standard for defining the term.  \n其实 Unix-like 是个相对模糊的概念：\n\n* 最狭义的 Unix 单指 Bell Labs's Unix\n* 稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X\n* 最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等\n\n#### Single UNIX Specification\nThe Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to **qualify for the name \"Unix\"**, like **POSIX**.\n\n#### Apple iOS\niOS is a **Unix-like OS based on Darwin(BSD)** and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, **making iOS not fully Unix-compatible either.**\n\nThe iOS kernal is **XNU**, the kernal of Darwin.\n\n#### XNU Kernel\nXNU, the acronym(首字母缩写) for ***X is Not Unix***, which is the **Computer OS Kernel** developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.\n\n\n---\n\n## Linux\n\n\n> Linux is a Unix-like and mostly POSIX-compliant computer OS.\n\n\n![Unix_timeline](http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png)\n\n\n#### Linux Kernel\n\n严格来讲，术语 Linux 只表示 [Linux Kernel](http://en.wikipedia.org/wiki/Linux_kernel) 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。\n\n但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）\n\n这类操作系统也被称为 **GNU/Linux**\n\n\n#### GNU Project\n\nThe GNU Project is a **free software, mass collaboration** project, which based on the following freedom rights:\n\n* Users are free to run the software, share (copy, distribute), study and modify it.\n* GNU software guarantees these freedom-rights legally (via its license).\n* So it is not only FREE but, more important, FREEDOM.\n\nIn order to ensure that the *entire* software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, **the operating system**, needed to be written.\n\nThis OS is decided to called **GNU (a recursive acronym meaning \"GNU is not Unix\")**. By 1992, the GNU Project had completed all of the major OS components except for their kernel, *GNU Hurd*.\n\nWith the release of the third-party **Linux Kernel**, started independently by *Linus Torvalds* in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS **composed completely of free software**.\n\nThough the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.\n\nAnyway, there eventually comes to the **GNU/Linux**\n\n\n* **GPL**: GNU General Public License\n* **GCC**: GNU Compiler Collection\n\n其他与 GPL 相关的自由/开源软件公共许可证：\n\n* [Mozilla Public License](http://en.wikipedia.org/wiki/Mozilla_Public_License)\n* [MIT License](http://en.wikipedia.org/wiki/MIT_License)\n* [BSD Public License](http://en.wikipedia.org/wiki/BSD_licenses)\n\t* GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭\n* [Apache License](http://en.wikipedia.org/wiki/Apache_License)\n\n![Public License](http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png)\n\n#### Android\n\nAndroid is a mobile OS based on **Linux Kernel**, so it's definitely **Unix-like**.  \n\n**Linux is under GPL so Android has to be open source**.\nAndroid's source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google *(GMS are all proprietary)*  \n\n#### Android Kernel\n\nAndroid's kernel is based on one of the Linux kernel's long-term support (LTS) branches.   \n\n**Android's variant of the Linux kernel** has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.\n\nAndroid Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。\n\n\n#### Android ROM\n\n既然提到 Android 就不得不提提 Android ROM\n\nROM 的本义实际上是只读内存：  \n\n**Read-only memory** (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is **mainly used to distribute firmware (固件)** (software that is very closely tied to specific hardware, and unlikely to need frequent updates).\n\nROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  \n\n* PROM (Programmable read-only memory)\n* EPROM (Erasable programmable read-only memory)\n* EEPROM (Electrically erasable programmable read-only memory)\n\t* Flash memory (闪存)\n\nFlash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。\n\n所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。\n\n所以在 wiki 里是没有 Android ROM 这个词条的，只有 [List of custom Android firmwares](http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares)\n\n> A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.\n\n各类 Android ROM 在 Android 词类下也都是属于 **Forks and distributions** 一类的。\n\n所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……**其实 ROM 和 Distribution OS 的界限是很模糊的**，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？\n\n#### Chrome OS\n\nChrome OS is an operating system based on the **Linux kernel** and designed by Google to work with web applications and installed applications.\n\n虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……\n\n* **Chrome Packaged Application** (Support working offline and installed)\n* **Android App Runtime** (run Android applications natively...fxxking awesome)\n\n平复一下激动的心情，还是回到正题来：\n\n#### Chromium OS\n\nChrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a **Linux distribution** designed by Google.\n\nFor Detail, Chromium OS based on [Gentoo Linux](http://en.wikipedia.org/wiki/Gentoo_Linux), emm...\n","slug":"unix-linux-note","published":1,"updated":"2017-05-27T07:31:52.000Z","comments":1,"photos":[],"link":"","_id":"cj36yugar000dwkt7v5afb8sh","content":"<blockquote>\n<p>This document is not completed and will be updated anytime.</p>\n</blockquote>\n<h2 id=\"Catagory\"><a href=\"#Catagory\" class=\"headerlink\" title=\"Catagory\"></a>Catagory</h2><ol>\n<li><a href=\"#unix\">Unix</a><ol>\n<li><a href=\"#bell-labs\">Bell Labs</a></li>\n<li><a href=\"#xenix\">Xenix</a></li>\n<li><a href=\"#bsd\">BSD</a></li>\n<li><a href=\"#freebsd--apple\">FreeBSD &amp; Apple</a></li>\n<li><a href=\"#nextstep\">NeXTStep</a></li>\n<li><a href=\"#darwin\">Darwin</a></li>\n<li><a href=\"#posix\">POSIX</a></li>\n</ol>\n</li>\n<li><a href=\"#unix-like\">Unix-like</a><ol>\n<li><a href=\"#single-unix-specification\">Single Unix Specification</a></li>\n<li><a href=\"#apple-ios\">Apple iOS</a></li>\n<li><a href=\"#xnu-kernel\">XNU Kernel</a></li>\n</ol>\n</li>\n<li><a href=\"#linux\">Linux</a><ol>\n<li><a href=\"#linux-kernel\">Linux Kernel</a></li>\n<li><a href=\"#gnu-project\">GNU Project</a></li>\n<li><a href=\"#android\">Android</a></li>\n<li><a href=\"#android-kernel\">Android Kernel</a></li>\n<li><a href=\"#android-rom\">Android ROM</a></li>\n<li><a href=\"#chrome-os\">Chrome OS</a></li>\n<li><a href=\"#chromium-os\">Chromium OS</a></li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"Unix\"><a href=\"#Unix\" class=\"headerlink\" title=\"Unix\"></a>Unix</h2><blockquote>\n<p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p>\n</blockquote>\n<p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p>\n<ul>\n<li><h4 id=\"Bell-Labs\"><a href=\"#Bell-Labs\" class=\"headerlink\" title=\"Bell Labs\"></a>Bell Labs</h4>Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。<br><strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</li>\n</ul>\n<p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p>\n<ul>\n<li><h4 id=\"Xenix\"><a href=\"#Xenix\" class=\"headerlink\" title=\"Xenix\"></a>Xenix</h4><p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p>\n</li>\n<li><h4 id=\"BSD\"><a href=\"#BSD\" class=\"headerlink\" title=\"BSD\"></a>BSD</h4><p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)</p>\n<ul>\n<li><strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）</li>\n<li>BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</li>\n</ul>\n</li>\n<li><h4 id=\"FreeBSD-amp-Apple\"><a href=\"#FreeBSD-amp-Apple\" class=\"headerlink\" title=\"FreeBSD &amp; Apple\"></a>FreeBSD &amp; Apple</h4><p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p>\n</li>\n<li><h4 id=\"NeXTSTEP\"><a href=\"#NeXTSTEP\" class=\"headerlink\" title=\"NeXTSTEP\"></a>NeXTSTEP</h4><p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several “kits”.<br>大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p>\n</li>\n<li><h4 id=\"Darwin\"><a href=\"#Darwin\" class=\"headerlink\" title=\"Darwin\"></a>Darwin</h4><p><a href=\"http://en.wikipedia.org/wiki/Darwin_(operating_system\\\" target=\"_blank\" rel=\"external\">Darwin</a>), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)<br><strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p>\n</li>\n<li><h4 id=\"POSIX\"><a href=\"#POSIX\" class=\"headerlink\" title=\"POSIX\"></a>POSIX</h4><p>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.</p>\n<ul>\n<li>Fully POSIX compliant:<ul>\n<li>OS X</li>\n<li>QNX OS (BlackBerry)</li>\n</ul>\n</li>\n<li>Mostly complicant:<ul>\n<li>Linux</li>\n<li>OpenBSD/FreeBSD</li>\n<li>Darwin (Core of <strong>iOS</strong> &amp; OS X)</li>\n<li><strong>Android</strong></li>\n</ul>\n</li>\n<li>Complicant via compatibility feature （通过兼容功能实现兼容）<ul>\n<li>Windows NT Kernel<ul>\n<li>Windows Server 2000, 2003, 2008, 2008 R2, 2012</li>\n</ul>\n</li>\n<li>Symbian OS (with PIPS)<ul>\n<li>Symbian was a closed-source OS.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Unix-like\"><a href=\"#Unix-like\" class=\"headerlink\" title=\"Unix-like\"></a>Unix-like</h2><blockquote>\n<p>A Unix-like (sometimes referred to as UN<em>X or </em>nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the <strong>Single UNIX Specification</strong>.</p>\n</blockquote>\n<p>There is no standard for defining the term.<br>其实 Unix-like 是个相对模糊的概念：</p>\n<ul>\n<li>最狭义的 Unix 单指 Bell Labs’s Unix</li>\n<li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li>\n<li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li>\n</ul>\n<h4 id=\"Single-UNIX-Specification\"><a href=\"#Single-UNIX-Specification\" class=\"headerlink\" title=\"Single UNIX Specification\"></a>Single UNIX Specification</h4><p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name “Unix”</strong>, like <strong>POSIX</strong>.</p>\n<h4 id=\"Apple-iOS\"><a href=\"#Apple-iOS\" class=\"headerlink\" title=\"Apple iOS\"></a>Apple iOS</h4><p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p>\n<p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p>\n<h4 id=\"XNU-Kernel\"><a href=\"#XNU-Kernel\" class=\"headerlink\" title=\"XNU Kernel\"></a>XNU Kernel</h4><p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p>\n<hr>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><blockquote>\n<p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p>\n</blockquote>\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png\" alt=\"Unix_timeline\"></p>\n<h4 id=\"Linux-Kernel\"><a href=\"#Linux-Kernel\" class=\"headerlink\" title=\"Linux Kernel\"></a>Linux Kernel</h4><p>严格来讲，术语 Linux 只表示 <a href=\"http://en.wikipedia.org/wiki/Linux_kernel\" target=\"_blank\" rel=\"external\">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p>\n<p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p>\n<p>这类操作系统也被称为 <strong>GNU/Linux</strong></p>\n<h4 id=\"GNU-Project\"><a href=\"#GNU-Project\" class=\"headerlink\" title=\"GNU Project\"></a>GNU Project</h4><p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p>\n<ul>\n<li>Users are free to run the software, share (copy, distribute), study and modify it.</li>\n<li>GNU software guarantees these freedom-rights legally (via its license).</li>\n<li>So it is not only FREE but, more important, FREEDOM.</li>\n</ul>\n<p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p>\n<p>This OS is decided to called <strong>GNU (a recursive acronym meaning “GNU is not Unix”)</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p>\n<p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p>\n<p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p>\n<p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p>\n<ul>\n<li><strong>GPL</strong>: GNU General Public License</li>\n<li><strong>GCC</strong>: GNU Compiler Collection</li>\n</ul>\n<p>其他与 GPL 相关的自由/开源软件公共许可证：</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Mozilla_Public_License\" target=\"_blank\" rel=\"external\">Mozilla Public License</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/MIT_License\" target=\"_blank\" rel=\"external\">MIT License</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/BSD_licenses\" target=\"_blank\" rel=\"external\">BSD Public License</a><ul>\n<li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li>\n</ul>\n</li>\n<li><a href=\"http://en.wikipedia.org/wiki/Apache_License\" target=\"_blank\" rel=\"external\">Apache License</a></li>\n</ul>\n<p><img src=\"http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png\" alt=\"Public License\"></p>\n<h4 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h4><p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it’s definitely <strong>Unix-like</strong>.  </p>\n<p><strong>Linux is under GPL so Android has to be open source</strong>.<br>Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em>  </p>\n<h4 id=\"Android-Kernel\"><a href=\"#Android-Kernel\" class=\"headerlink\" title=\"Android Kernel\"></a>Android Kernel</h4><p>Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.   </p>\n<p><strong>Android’s variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p>\n<p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p>\n<h4 id=\"Android-ROM\"><a href=\"#Android-ROM\" class=\"headerlink\" title=\"Android ROM\"></a>Android ROM</h4><p>既然提到 Android 就不得不提提 Android ROM</p>\n<p>ROM 的本义实际上是只读内存：  </p>\n<p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p>\n<p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  </p>\n<ul>\n<li>PROM (Programmable read-only memory)</li>\n<li>EPROM (Erasable programmable read-only memory)</li>\n<li>EEPROM (Electrically erasable programmable read-only memory)<ul>\n<li>Flash memory (闪存)</li>\n</ul>\n</li>\n</ul>\n<p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p>\n<p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p>\n<p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href=\"http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares\" target=\"_blank\" rel=\"external\">List of custom Android firmwares</a></p>\n<blockquote>\n<p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p>\n</blockquote>\n<p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p>\n<p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p>\n<h4 id=\"Chrome-OS\"><a href=\"#Chrome-OS\" class=\"headerlink\" title=\"Chrome OS\"></a>Chrome OS</h4><p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p>\n<p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p>\n<ul>\n<li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li>\n<li><strong>Android App Runtime</strong> (run Android applications natively…fxxking awesome)</li>\n</ul>\n<p>平复一下激动的心情，还是回到正题来：</p>\n<h4 id=\"Chromium-OS\"><a href=\"#Chromium-OS\" class=\"headerlink\" title=\"Chromium OS\"></a>Chromium OS</h4><p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p>\n<p>For Detail, Chromium OS based on <a href=\"http://en.wikipedia.org/wiki/Gentoo_Linux\" target=\"_blank\" rel=\"external\">Gentoo Linux</a>, emm…</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This document is not completed and will be updated anytime.</p>\n</blockquote>\n<h2 id=\"Catagory\"><a href=\"#Catagory\" class=\"headerlink\" title=\"Catagory\"></a>Catagory</h2><ol>\n<li><a href=\"#unix\">Unix</a><ol>\n<li><a href=\"#bell-labs\">Bell Labs</a></li>\n<li><a href=\"#xenix\">Xenix</a></li>\n<li><a href=\"#bsd\">BSD</a></li>\n<li><a href=\"#freebsd--apple\">FreeBSD &amp; Apple</a></li>\n<li><a href=\"#nextstep\">NeXTStep</a></li>\n<li><a href=\"#darwin\">Darwin</a></li>\n<li><a href=\"#posix\">POSIX</a></li>\n</ol>\n</li>\n<li><a href=\"#unix-like\">Unix-like</a><ol>\n<li><a href=\"#single-unix-specification\">Single Unix Specification</a></li>\n<li><a href=\"#apple-ios\">Apple iOS</a></li>\n<li><a href=\"#xnu-kernel\">XNU Kernel</a></li>\n</ol>\n</li>\n<li><a href=\"#linux\">Linux</a><ol>\n<li><a href=\"#linux-kernel\">Linux Kernel</a></li>\n<li><a href=\"#gnu-project\">GNU Project</a></li>\n<li><a href=\"#android\">Android</a></li>\n<li><a href=\"#android-kernel\">Android Kernel</a></li>\n<li><a href=\"#android-rom\">Android ROM</a></li>\n<li><a href=\"#chrome-os\">Chrome OS</a></li>\n<li><a href=\"#chromium-os\">Chromium OS</a></li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"Unix\"><a href=\"#Unix\" class=\"headerlink\" title=\"Unix\"></a>Unix</h2><blockquote>\n<p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p>\n</blockquote>\n<p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p>\n<ul>\n<li><h4 id=\"Bell-Labs\"><a href=\"#Bell-Labs\" class=\"headerlink\" title=\"Bell Labs\"></a>Bell Labs</h4>Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。<br><strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</li>\n</ul>\n<p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p>\n<ul>\n<li><h4 id=\"Xenix\"><a href=\"#Xenix\" class=\"headerlink\" title=\"Xenix\"></a>Xenix</h4><p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p>\n</li>\n<li><h4 id=\"BSD\"><a href=\"#BSD\" class=\"headerlink\" title=\"BSD\"></a>BSD</h4><p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)</p>\n<ul>\n<li><strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）</li>\n<li>BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</li>\n</ul>\n</li>\n<li><h4 id=\"FreeBSD-amp-Apple\"><a href=\"#FreeBSD-amp-Apple\" class=\"headerlink\" title=\"FreeBSD &amp; Apple\"></a>FreeBSD &amp; Apple</h4><p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p>\n</li>\n<li><h4 id=\"NeXTSTEP\"><a href=\"#NeXTSTEP\" class=\"headerlink\" title=\"NeXTSTEP\"></a>NeXTSTEP</h4><p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several “kits”.<br>大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p>\n</li>\n<li><h4 id=\"Darwin\"><a href=\"#Darwin\" class=\"headerlink\" title=\"Darwin\"></a>Darwin</h4><p><a href=\"http://en.wikipedia.org/wiki/Darwin_(operating_system\\\" target=\"_blank\" rel=\"external\">Darwin</a>), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)<br><strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p>\n</li>\n<li><h4 id=\"POSIX\"><a href=\"#POSIX\" class=\"headerlink\" title=\"POSIX\"></a>POSIX</h4><p>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.</p>\n<ul>\n<li>Fully POSIX compliant:<ul>\n<li>OS X</li>\n<li>QNX OS (BlackBerry)</li>\n</ul>\n</li>\n<li>Mostly complicant:<ul>\n<li>Linux</li>\n<li>OpenBSD/FreeBSD</li>\n<li>Darwin (Core of <strong>iOS</strong> &amp; OS X)</li>\n<li><strong>Android</strong></li>\n</ul>\n</li>\n<li>Complicant via compatibility feature （通过兼容功能实现兼容）<ul>\n<li>Windows NT Kernel<ul>\n<li>Windows Server 2000, 2003, 2008, 2008 R2, 2012</li>\n</ul>\n</li>\n<li>Symbian OS (with PIPS)<ul>\n<li>Symbian was a closed-source OS.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"Unix-like\"><a href=\"#Unix-like\" class=\"headerlink\" title=\"Unix-like\"></a>Unix-like</h2><blockquote>\n<p>A Unix-like (sometimes referred to as UN<em>X or </em>nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the <strong>Single UNIX Specification</strong>.</p>\n</blockquote>\n<p>There is no standard for defining the term.<br>其实 Unix-like 是个相对模糊的概念：</p>\n<ul>\n<li>最狭义的 Unix 单指 Bell Labs’s Unix</li>\n<li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li>\n<li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li>\n</ul>\n<h4 id=\"Single-UNIX-Specification\"><a href=\"#Single-UNIX-Specification\" class=\"headerlink\" title=\"Single UNIX Specification\"></a>Single UNIX Specification</h4><p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name “Unix”</strong>, like <strong>POSIX</strong>.</p>\n<h4 id=\"Apple-iOS\"><a href=\"#Apple-iOS\" class=\"headerlink\" title=\"Apple iOS\"></a>Apple iOS</h4><p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p>\n<p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p>\n<h4 id=\"XNU-Kernel\"><a href=\"#XNU-Kernel\" class=\"headerlink\" title=\"XNU Kernel\"></a>XNU Kernel</h4><p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p>\n<hr>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><blockquote>\n<p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p>\n</blockquote>\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png\" alt=\"Unix_timeline\"></p>\n<h4 id=\"Linux-Kernel\"><a href=\"#Linux-Kernel\" class=\"headerlink\" title=\"Linux Kernel\"></a>Linux Kernel</h4><p>严格来讲，术语 Linux 只表示 <a href=\"http://en.wikipedia.org/wiki/Linux_kernel\" target=\"_blank\" rel=\"external\">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p>\n<p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p>\n<p>这类操作系统也被称为 <strong>GNU/Linux</strong></p>\n<h4 id=\"GNU-Project\"><a href=\"#GNU-Project\" class=\"headerlink\" title=\"GNU Project\"></a>GNU Project</h4><p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p>\n<ul>\n<li>Users are free to run the software, share (copy, distribute), study and modify it.</li>\n<li>GNU software guarantees these freedom-rights legally (via its license).</li>\n<li>So it is not only FREE but, more important, FREEDOM.</li>\n</ul>\n<p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p>\n<p>This OS is decided to called <strong>GNU (a recursive acronym meaning “GNU is not Unix”)</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p>\n<p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p>\n<p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p>\n<p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p>\n<ul>\n<li><strong>GPL</strong>: GNU General Public License</li>\n<li><strong>GCC</strong>: GNU Compiler Collection</li>\n</ul>\n<p>其他与 GPL 相关的自由/开源软件公共许可证：</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Mozilla_Public_License\" target=\"_blank\" rel=\"external\">Mozilla Public License</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/MIT_License\" target=\"_blank\" rel=\"external\">MIT License</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/BSD_licenses\" target=\"_blank\" rel=\"external\">BSD Public License</a><ul>\n<li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li>\n</ul>\n</li>\n<li><a href=\"http://en.wikipedia.org/wiki/Apache_License\" target=\"_blank\" rel=\"external\">Apache License</a></li>\n</ul>\n<p><img src=\"http://dl2.iteye.com/upload/attachment/0047/4142/d770c85a-49b7-3c7f-8ae2-cbb6451e00d8.png\" alt=\"Public License\"></p>\n<h4 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h4><p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it’s definitely <strong>Unix-like</strong>.  </p>\n<p><strong>Linux is under GPL so Android has to be open source</strong>.<br>Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em>  </p>\n<h4 id=\"Android-Kernel\"><a href=\"#Android-Kernel\" class=\"headerlink\" title=\"Android Kernel\"></a>Android Kernel</h4><p>Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.   </p>\n<p><strong>Android’s variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p>\n<p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p>\n<h4 id=\"Android-ROM\"><a href=\"#Android-ROM\" class=\"headerlink\" title=\"Android ROM\"></a>Android ROM</h4><p>既然提到 Android 就不得不提提 Android ROM</p>\n<p>ROM 的本义实际上是只读内存：  </p>\n<p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p>\n<p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  </p>\n<ul>\n<li>PROM (Programmable read-only memory)</li>\n<li>EPROM (Erasable programmable read-only memory)</li>\n<li>EEPROM (Electrically erasable programmable read-only memory)<ul>\n<li>Flash memory (闪存)</li>\n</ul>\n</li>\n</ul>\n<p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p>\n<p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p>\n<p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href=\"http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares\" target=\"_blank\" rel=\"external\">List of custom Android firmwares</a></p>\n<blockquote>\n<p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p>\n</blockquote>\n<p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p>\n<p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p>\n<h4 id=\"Chrome-OS\"><a href=\"#Chrome-OS\" class=\"headerlink\" title=\"Chrome OS\"></a>Chrome OS</h4><p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p>\n<p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p>\n<ul>\n<li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li>\n<li><strong>Android App Runtime</strong> (run Android applications natively…fxxking awesome)</li>\n</ul>\n<p>平复一下激动的心情，还是回到正题来：</p>\n<h4 id=\"Chromium-OS\"><a href=\"#Chromium-OS\" class=\"headerlink\" title=\"Chromium OS\"></a>Chromium OS</h4><p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p>\n<p>For Detail, Chromium OS based on <a href=\"http://en.wikipedia.org/wiki/Gentoo_Linux\" target=\"_blank\" rel=\"external\">Gentoo Linux</a>, emm…</p>\n"}],"PostAsset":[{"_id":"source/_posts/hello-2015/post-bg-2015.jpg","slug":"post-bg-2015.jpg","post":"cj36yuga50003wkt7j9h0v38p","modified":0,"renderable":0},{"_id":"source/_posts/js-module-loader/post-bg-js-module.jpg","slug":"post-bg-js-module.jpg","post":"cj36yugaa0005wkt7mflvilvm","modified":0,"renderable":0},{"_id":"source/_posts/unix-linux-note/post-bg-unix-linux.jpg","slug":"post-bg-unix-linux.jpg","post":"cj36yugar000dwkt7v5afb8sh","modified":0,"renderable":0},{"_id":"source/_posts/js-version/javascript-java.jpg","slug":"javascript-java.jpg","post":"cj36yugao000awkt72rtemu3c","modified":0,"renderable":0},{"_id":"source/_posts/js-version/keep-calm-and-learn-javascript.png","slug":"keep-calm-and-learn-javascript.png","post":"cj36yugao000awkt72rtemu3c","modified":0,"renderable":0},{"_id":"source/_posts/js-version/post-bg-js-version.jpg","slug":"post-bg-js-version.jpg","post":"cj36yugao000awkt72rtemu3c","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cj36yuga50003wkt7j9h0v38p","tag_id":"cj36yugad0007wkt7lhi4lol3","_id":"cj36yugaq000cwkt75m9bivjj"},{"post_id":"cj36yugaa0005wkt7mflvilvm","tag_id":"cj36yugaq000bwkt7u8ml89q3","_id":"cj36yugau000gwkt7742ksnc1"},{"post_id":"cj36yugaa0005wkt7mflvilvm","tag_id":"cj36yugas000ewkt7qb3w7gy1","_id":"cj36yugau000hwkt7nyn8byec"},{"post_id":"cj36yugak0008wkt7kh305vys","tag_id":"cj36yugaq000bwkt7u8ml89q3","_id":"cj36yugav000kwkt7g6hbrg01"},{"post_id":"cj36yugak0008wkt7kh305vys","tag_id":"cj36yugas000ewkt7qb3w7gy1","_id":"cj36yugav000lwkt7nktizq80"},{"post_id":"cj36yugam0009wkt73vk2pe25","tag_id":"cj36yugav000jwkt7u5iqxsfq","_id":"cj36yugax000nwkt7cf5pi1fp"},{"post_id":"cj36yugao000awkt72rtemu3c","tag_id":"cj36yugaq000bwkt7u8ml89q3","_id":"cj36yugb1000rwkt7xeu95xqd"},{"post_id":"cj36yugao000awkt72rtemu3c","tag_id":"cj36yugas000ewkt7qb3w7gy1","_id":"cj36yugb1000swkt7ijmis4e5"},{"post_id":"cj36yugao000awkt72rtemu3c","tag_id":"cj36yugb0000pwkt7vsozya1r","_id":"cj36yugb1000uwkt79w7gs3m1"},{"post_id":"cj36yugar000dwkt7v5afb8sh","tag_id":"cj36yugb0000qwkt7nuc9uyv3","_id":"cj36yugb2000wwkt7jwpdnvo0"},{"post_id":"cj36yugar000dwkt7v5afb8sh","tag_id":"cj36yugb1000twkt76msrnl28","_id":"cj36yugb2000xwkt71gq27rpq"},{"post_id":"cj36yugar000dwkt7v5afb8sh","tag_id":"cj36yugb1000vwkt7326vrlx8","_id":"cj36yugb2000ywkt7m5iczcev"}],"Tag":[{"name":"生活","_id":"cj36yugad0007wkt7lhi4lol3"},{"name":"前端开发","_id":"cj36yugaq000bwkt7u8ml89q3"},{"name":"JavaScript","_id":"cj36yugas000ewkt7qb3w7gy1"},{"name":"Promise","_id":"cj36yugav000jwkt7u5iqxsfq"},{"name":"翻译","_id":"cj36yugb0000pwkt7vsozya1r"},{"name":"OS","_id":"cj36yugb0000qwkt7nuc9uyv3"},{"name":"Unix","_id":"cj36yugb1000twkt76msrnl28"},{"name":"Linux","_id":"cj36yugb1000vwkt7326vrlx8"}]}}